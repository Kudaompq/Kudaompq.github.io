<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>滑动窗口算法</title>
      <link href="2021/02/07/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
      <url>2021/02/07/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><blockquote><p>动态的去维护一个窗口的大小，从而减少数组问题或者字符串问题的复杂度</p></blockquote><ul><li>指定窗口大小，求最大最小值</li><li>指定值，求最大最小窗口大小</li></ul><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li>考虑窗口的平移</li><li>考虑窗口的扩张与收缩</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>用于求小于指定值的最值大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;伪代码</span><br><span class="line">&#x2F;&#x2F;设定一个虚拟窗口，设置左右指针，数组大小len</span><br><span class="line">&#x2F;&#x2F;初始化好的数组</span><br><span class="line">int[] nums;</span><br><span class="line">int left &#x3D; 0, right &#x3D; 0;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;右指针一直往右，窗口大小增大</span><br><span class="line">for (; right &lt; len ; right++)&#123;</span><br><span class="line">sum +&#x3D; nums[right];</span><br><span class="line">while(sum &gt; 设定值)&#123;</span><br><span class="line">&#x2F;&#x2F;减去左指针指向的值同时左指针右移，窗口大小减小</span><br><span class="line">sum -&#x3D; nums[left];</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">窗口最大值 &#x3D; Math.max(窗口最大值,right - left + 1);</span><br><span class="line">&#125;</span><br><span class="line">return 窗口最大值;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>选自：<a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">https://leetcode-cn.com/problems/get-equal-substrings-within-budget/</a></p><p><img src="/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/image-20210207213730709.png" alt="image-20210207213730709"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ul><li>题意其实是求两连续子串之间的绝对值差小于cost，同时长度最长</li><li>将两个字符串转换为字符数组，再相减转换成绝对值数组</li><li>利用滑动窗口求最大长度</li></ul><h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int equalSubstring(String s, String t, int maxCost) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.转换成差值数组</span><br><span class="line">        char[] ch_s &#x3D; s.toCharArray();</span><br><span class="line">        char[] ch_t &#x3D; t.toCharArray();</span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        int[] nums &#x3D; new int[len];</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; len ; i++)&#123;</span><br><span class="line">            nums[i] &#x3D; Math.abs(ch_s[i] - ch_t[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 2.利用滑动窗口获取小于maxCost的最长数组</span><br><span class="line">        int left &#x3D; 0 , right &#x3D; 0;</span><br><span class="line">        int max_len &#x3D; -1;</span><br><span class="line">        int current &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;右指针自动向右</span><br><span class="line">        for (;right &lt; len ;right++)&#123;</span><br><span class="line">        &#x2F;&#x2F;添加右指针指向的值</span><br><span class="line">            current +&#x3D; nums[right];   </span><br><span class="line">            &#x2F;&#x2F;当当前窗口的值大于指定值时，左指针指向内容离开数组，同时左指针向右移动</span><br><span class="line">            while(current &gt; maxCost)&#123;</span><br><span class="line">                current -&#x3D; nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;比较当前窗口是否为最大</span><br><span class="line">            max_len &#x3D; Math.max(max_len,right - left + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换问题"><a href="#替换问题" class="headerlink" title="替换问题"></a>替换问题</h2><p>选自：<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">https://leetcode-cn.com/problems/longest-repeating-character-replacement/</a></p><p><img src="/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/image-20210209114502359.png" alt="image-20210209114502359"></p><h3 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h3><ul><li>滑动窗口题，因为要求连续字串内的包含最多重复字母的长度</li><li>其实就是求最多重复字母个数 + 可替换次数 的最小窗口</li><li>维护窗口的同时，记录窗口内最大重复字母个数</li><li>当窗口大小 &gt; 最大重复字母个数 + K时缩小窗口</li><li>最后窗口大小就是答案</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int characterReplacement(String s, int k) &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置left，right，每次循环right都会向右移动</span><br><span class="line">        &#x2F;&#x2F; 如果满足条件left不变（相当于窗口大小增大），不满足left++（相当于窗口大小减小）</span><br><span class="line">        int[] map &#x3D; new int[26];</span><br><span class="line">        char[] ch &#x3D; s.toCharArray();</span><br><span class="line">        int left &#x3D; 0 , right &#x3D; 0, maxLen &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;right会自动维护</span><br><span class="line">        for (;right &lt; ch.length ; right++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 获得新加入的字母</span><br><span class="line">            int index &#x3D; ch[right] - &#39;A&#39;;</span><br><span class="line">            &#x2F;&#x2F;维护字母个数数组</span><br><span class="line">            map[index]++;</span><br><span class="line">            &#x2F;&#x2F; 将最右边的字母的个数与原来最大值进行比较，从而获得窗口的最大值</span><br><span class="line">            maxLen &#x3D; Math.max(maxLen,map[index]);</span><br><span class="line">            &#x2F;&#x2F; 如果当前窗口大于最长重复字符 + K，就要缩小窗口</span><br><span class="line">            if (right - left + 1 &gt; maxLen + k)&#123;</span><br><span class="line">                &#x2F;&#x2F; 最左边的点移除窗口</span><br><span class="line">                map[ch[left] - &#39;A&#39;]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 最后窗口的大小就是答案</span><br><span class="line">        return ch.length - left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求满足子数组个数问题"><a href="#求满足子数组个数问题" class="headerlink" title="求满足子数组个数问题"></a>求满足子数组个数问题</h2><p>选自：<a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">https://leetcode-cn.com/problems/subarray-product-less-than-k/</a></p><p><img src="/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/image-20210209122506884.png" alt="image-20210209122506884"></p><h3 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a>解题思路：</h3><ul><li>滑动窗口模板题</li><li>要点在于如何记录子数组的数量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numSubarrayProductLessThanK(int[] nums, int k) &#123;</span><br><span class="line">        if (k &#x3D;&#x3D; 0 || k &#x3D;&#x3D; 1) return 0;</span><br><span class="line">        int left &#x3D; 0 ,right &#x3D; 0;</span><br><span class="line">        int sum &#x3D; 1;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        for (;right &lt; nums.length ;right++)&#123;</span><br><span class="line">            sum *&#x3D; nums[right];</span><br><span class="line">            while(sum &gt;&#x3D; k)&#123;</span><br><span class="line">                sum &#x2F;&#x3D; nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;此刻的right - left + 1表示加入right指针所指元素后新增的子数组数量</span><br><span class="line">            res +&#x3D; right - left + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间范围内子串个数问题"><a href="#区间范围内子串个数问题" class="headerlink" title="区间范围内子串个数问题"></a>区间范围内子串个数问题</h2><p><img src="/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/image-20210209153902899.png" alt="image-20210209153902899"></p><h3 id="解题思路：-3"><a href="#解题思路：-3" class="headerlink" title="解题思路："></a>解题思路：</h3><ul><li>子数组问题可以联想到滑动窗口问题</li><li>与普通滑动窗口问题不同，它的右边界不确定</li><li>解决办法：在左边界确定的情况下确定最小右边界，最大右边界</li><li>转换成最大元素小于指定值问题</li><li>答案就是最大值为R的子串数 - 最大值为L - 1的子串数</li></ul><p>算法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numSubarrayBoundedMax(int[] A, int L, int R) &#123;</span><br><span class="line">        &#x2F;&#x2F;把问题转换成  最大值为R的子串数 - 最大值为L - 1的子串数</span><br><span class="line">        return helper(A,R) - helper(A,L - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    private int helper(int[] A,int R)&#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (int num:A)&#123;</span><br><span class="line">            if (num &lt;&#x3D; R )&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                res +&#x3D; sum;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sum &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> Sliding Window </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话技术</title>
      <link href="2021/02/01/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"/>
      <url>2021/02/01/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><blockquote><p>从打开一个浏览器访问某个站点，到<strong>关闭这个浏览器</strong>的整个过程，称为一次会话。</p><p>会话技术就是记录这次会话中的状态与数据</p></blockquote><p>会话分类</p><ul><li>Cookie<ul><li>数据存储在客户端本地，减少服务器端的存储的压力，安全性不好，客户端可以消除Cookie</li></ul></li><li>Session<ul><li>将数据存储到服务器端，安全性相对好，增加服务器的压力    </li></ul></li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie技术是将用户数据存储到客户端的技术</p><ul><li>服务器端怎样把一个Cookie发送到客户端</li><li>服务器端怎样接受客户端携带的Cookie</li></ul><h3 id="服务器端向客户端发送一个Cookie"><a href="#服务器端向客户端发送一个Cookie" class="headerlink" title="服务器端向客户端发送一个Cookie"></a>服务器端向客户端发送一个Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.创建Cookie</span><br><span class="line">Cookie cookie &#x3D; new Cookie(String cookieName,String cookieValue);</span><br><span class="line">&#x2F;&#x2F;Cookie不能存储中文</span><br><span class="line">    示例：Cookie cookie &#x3D; new Cookie(&quot;goods&quot;,&quot;cup&quot;);</span><br><span class="line">    goods &#x3D; cup</span><br><span class="line"></span><br><span class="line">2.向客户端发送cookie       </span><br><span class="line">    response.addCookie(Cookie cookie);</span><br></pre></td></tr></table></figure><h3 id="Cookie常见API"><a href="#Cookie常见API" class="headerlink" title="Cookie常见API"></a>Cookie常见API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.设置Cookie在客户端的持久化时间</span><br><span class="line">cookie.setMaxAge(int seconds); --单位秒</span><br><span class="line"></span><br><span class="line">注意：如果不设置持久化时间，cookie会存储在浏览器的内存中，如果浏览器关闭，cookie信息也会销毁（会话级别的cookie），如果设置持久化时间，cookie信息会持久化到浏览器的磁盘文件中</span><br><span class="line">示例：cookie.setMaxAge(10*60); 设置存储时间10分钟，过期浏览器自动删除</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2.设置Cookie的携带路径</span><br><span class="line">cookie.setPath(String path)</span><br><span class="line">注意：如果不设置携带路径，那么该cookie信息会在访问产生该cookie的web资源所在的路径都携带cookie信息</span><br><span class="line">示例：</span><br><span class="line">cookie.setPath(&quot;&#x2F;hello&quot;)</span><br><span class="line">代表访问hello应用中任何资源都携带cookie</span><br><span class="line">cookie.setPath(&quot;&#x2F;hello&#x2F;getCookie&quot;)</span><br><span class="line">代表访问hello中的getCookie是才携带cookie信息</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.向客户端发送cookie</span><br><span class="line">response.addCookie(Cookie cookie);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4.删除客户端中的cookie</span><br><span class="line">如果想删除客户端的已经存储的cookie信息，那么就是用同名同路径的持久化时间为0的cookie进行覆盖即可</span><br><span class="line"></span><br><span class="line">注意：必须同名同路径</span><br></pre></td></tr></table></figure><h3 id="服务器获取客户端携带来的Cookie"><a href="#服务器获取客户端携带来的Cookie" class="headerlink" title="服务器获取客户端携带来的Cookie"></a>服务器获取客户端携带来的Cookie</h3><blockquote><p>cookie信息是以请求头的方式发送到服务器端的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.通过request获取所有的Cookie</span><br><span class="line">Cookie[] cookies &#x3D; request.getCookies()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.遍历Cookie，通过Cookie的名称获取我们想要的Cookie</span><br><span class="line">for (Cookie cookie : cookies) &#123;</span><br><span class="line">if(cookie.getName().equals(cookieNmae))&#123;</span><br><span class="line">String cookieValue &#x3D; cookie.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><blockquote><p>Session技术是将数据存储在服务器端的技术，会为每个客户端都创建一块内存空间存储客户的数据，但客户端每次都携带一个标识ID去服务器中寻找属于自己的内存空间。所以说Session的实现是基于Cookie，Session需要借助Cookie存储客户的唯一性标识<strong>JSESSIONID</strong></p></blockquote><h3 id="Session对象的获取"><a href="#Session对象的获取" class="headerlink" title="Session对象的获取"></a>Session对象的获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session &#x3D; request.getSession();</span><br><span class="line"></span><br><span class="line">此方法会获得专属于当前会话的Session对象，如果服务器没有该会话的Session对象，则会创建一个新的Session返回，如果已经有了属于该会话的Session，直接将已有的Session返回（实质就是根据JSESSIONID）判断该客户端是否在服务器上已经存在session</span><br></pre></td></tr></table></figure><h3 id="Session存取数据"><a href="#Session存取数据" class="headerlink" title="Session存取数据"></a>Session存取数据</h3><blockquote><p>Session对象也是一个域对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(String name,Object obj);</span><br><span class="line">session.getAttribute(String name);</span><br><span class="line">session.removeAttribute(String name);</span><br></pre></td></tr></table></figure><h3 id="Session生命周期"><a href="#Session生命周期" class="headerlink" title="Session生命周期"></a>Session生命周期</h3><ul><li><p><strong>创建</strong>：第一次执行request.getSession()时创建</p></li><li><p><strong>销毁</strong>：</p><ul><li><p>服务器（非正常）关闭时</p></li><li><p>session过期/失效（默认30分钟）</p><ul><li><p>时间从不操作服务器端的资源开始计时</p></li><li><p>可以在web.xml中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">&lt;session-timeout&gt;你需要的时间&lt;&#x2F;session_timeout&gt;</span><br><span class="line">&lt;session-config&gt;</span><br></pre></td></tr></table></figure><h3 id="Session的持久化"><a href="#Session的持久化" class="headerlink" title="Session的持久化"></a>Session的持久化</h3></li></ul></li></ul></li></ul><blockquote><p>由于Session的创建和获取是取决于Cookie中的JESSIONID决定的，所以如果Cookie被清除了，服务器就无法找到对应的Session了，因此需要对Cookie中的JSESSIONS进行持久化才能使Session持久化</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session &#x3D; request.getSession();</span><br><span class="line">      Cookie cookie &#x3D; new Cookie(&quot;JSESSIONID&quot;, session.getId());</span><br><span class="line">      cookie.setMaxAge(60 * 60);</span><br><span class="line">      response.addCookie(cookie)</span><br><span class="line">      </span><br><span class="line">      注意：必须是JSESSIONID</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet学习</title>
      <link href="2021/02/01/Servlet%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/02/01/Servlet%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Servlet学习"><a href="#Servlet学习" class="headerlink" title="Servlet学习"></a>Servlet学习</h1><blockquote><p>Servlet是JavaWeb的核心程序，是javaWeb三大组件之一</p></blockquote><blockquote><p>Servlet（Server Applet）,全称Java Servlet，用于Java编写的服务器端程序，其主要功能在于交互式地浏览和修改数据，生成动态Web内容</p><ul><li>狭义理解为Java语言实现的一个接口</li><li>广义理解为任何实现了Servlet接口的类</li></ul></blockquote><blockquote><p>用于处理在HTTP请求过程中请求的参数 ：请求行的URL中（GET请求）或者请求体中（POST请求）</p></blockquote><p><strong>作用</strong>：</p><ol><li>获取接受客户端发送来的请求数据</li><li>处理请求</li><li>将处理的结果通过响应发送到客户端</li></ol><h2 id="创建Servlet程序"><a href="#创建Servlet程序" class="headerlink" title="创建Servlet程序"></a>创建Servlet程序</h2><ol><li><p>Servlet程序必须编写实现类</p><ol><li>继承javax.servlet.http.HttpServlet</li></ol></li><li><p>复写HttpServlet中的doGet()、doPost()方法</p><ol><li>复写doGet()</li><li>复写doPost()</li></ol></li><li><p>配置web.xml文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">      &lt;servletname&gt;helloServlet&lt;&#x2F;servletname&gt;</span><br><span class="line">      &lt;servletclass&gt;net.zixue.servlet.HelloServlt&lt;&#x2F;servlet-class&gt;</span><br><span class="line">  &lt;&#x2F;servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">      &lt;servletname&gt;helloServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">      &lt;url-pattern&gt;&#x2F;hi&lt;&#x2F;url-pattern&gt;  </span><br><span class="line">  &lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure><ol><li><servlet>是用来注册Servlet的</li><li>内部得到<servlet-name>是servlet的名称，在当前配置文件中必须唯一</li><li>内部的<servlet-class>是servlet实现类的类名，类名要包含包名</li><li><url-pattern>配置地址</li></ol></li><li><p>部署项目并通过浏览器访问servlet</p></li><li><p>Servlet的执行顺序</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">       &lt;servlet-name&gt;helloServlet&lt;&#x2F;servlet-name&gt;&#x2F;&#x2F;第三步</span><br><span class="line">       &lt;servlet-class&gt;net.zixue.servlet.HelloServlet&lt;&#x2F;servlet-class&gt;&#x2F;&#x2F;第四步</span><br><span class="line">   &lt;&#x2F;servlet&gt;</span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">       &lt;servlet-name&gt;helloServlet&lt;&#x2F;servlet-name&gt;&#x2F;&#x2F;第二步</span><br><span class="line">       &lt;url-pattern&gt;&#x2F;hi&lt;&#x2F;url-pattern&gt; &#x2F;&#x2F;第一步</span><br><span class="line">   &lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure><ul><li>第一步根据浏览器地址栏中访问得到接口名找到web.xml中对应的<servlet-mapping></li><li>第二步<servlet-mapping>会根据<url-pattern>对应到<servlet-name></li><li>第三步<servlet-name>会根据name对应到相同的<servlet>中</li><li>第四步找到同一标签中的<servlet-class>中的class</li></ul></li></ol><h2 id="使用Servlet3创建Servlet"><a href="#使用Servlet3创建Servlet" class="headerlink" title="使用Servlet3创建Servlet"></a>使用Servlet3创建Servlet</h2><ol><li><p>右键对应的包，new Servlet文件</p><ul><li><p><img src="/images/Servlet%E5%AD%A6%E4%B9%A0/image-20210110192048951.png"></p></li><li><p>如果没有new servlet文件的键需要去配置</p><ul><li><p>File-&gt;Project Structure-&gt;Modules</p></li><li><p><img src="/images/Servlet%E5%AD%A6%E4%B9%A0/image-20210110192244265.png"></p></li><li><p>最后在到Facets中<img src="/images/Servlet%E5%AD%A6%E4%B9%A0/image-20210110192325315.png"></p></li></ul></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;name 相当于servlet-name    urlPattern &#x3D; &quot;地址&quot;</span><br><span class="line">@WebServlet(name &#x3D; &quot;TestServlet&quot;,urlPatterns &#x3D; &quot;&#x2F;test&quot;)</span><br><span class="line">public class TestServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;收到了get请求&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><blockquote><p>作用：在Servlet的Api中定义了一个HttpServletRequest接口，它继承自ServletRequest接口，专门用于封装HTTP的请求，由于HTTP请求中包含请求行，请求头，请求体，在HttpServletRequest中分别定义了接受请求行，请求头和请求头的相关方法</p></blockquote><h3 id="获取请求行相关信息的相关方法"><a href="#获取请求行相关信息的相关方法" class="headerlink" title="获取请求行相关信息的相关方法"></a>获取请求行相关信息的相关方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;请求方式:&quot;+req.getMethod()</span><br><span class="line">2. &quot;URL:&quot; + req.getRequestURL()</span><br><span class="line">3. &quot;发出请求客户端的IP地址：&quot; + req.getRemoteAddr()</span><br><span class="line">4. &quot;服务点接受请求的IP地址：&quot; + req.getLocalAddr()</span><br><span class="line">5. &quot;访问客户端的端口号：&quot; + req.getRemotePort()</span><br><span class="line">6. &quot;web应用路径：&quot; + req.getContextPath()</span><br><span class="line">7. &quot;http协议和版本号：&quot; + req.getProtocol()</span><br></pre></td></tr></table></figure><h3 id="获取请求头的相关方法"><a href="#获取请求头的相关方法" class="headerlink" title="获取请求头的相关方法"></a>获取请求头的相关方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. getHeader(String name):该方法用于获取一个指定头字段的值，如果请求头中不包含该字段的值则返回null，如果有多个就返回第一个值</span><br><span class="line">2. getIntHeader(String name):该方法用于获取指定头字段的值，并且转成int类型，如果不存在返回-1，如果不能转成int型会抛出NumberFormatException异常</span><br><span class="line">3. getDateHeaders(String name)：该方法用于获取指定头字段的值，并且按照GMT时间格式转换成一个代表日期&#x2F;时间的长整数</span><br><span class="line">4. getHeaderNames()：该方法用于获取所有包含请求头字段的Enumeration   &#x2F;&#x2F;Enumeration是一个可遍历的类</span><br><span class="line"></span><br><span class="line">Enumeration&lt;String&gt; headerNames &#x3D; req.getHeaderNames();</span><br><span class="line">        while(headerNames.hasMoreElements())&#123;</span><br><span class="line">            String element &#x3D; headerNames.nextElement();</span><br><span class="line">            System.out.println(element + &quot;:&quot; + req.getHeader(element));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. getParameter(String name):用于获取某个指定名称的参数值，如果请求中没有包含指定名称的参数，则会返回null，如果有指定参数但没有给设置值，则返回空串“”，如果有多个只返回第一个</span><br><span class="line"></span><br><span class="line">2.getParameterNames()：该方法用于返回一个包含请求消息中所有参数名的Enumernation</span><br><span class="line"></span><br><span class="line">3.getParameterMaps():该方法用于将请求中的所有参数和值装入一个map对象然后返回</span><br><span class="line"></span><br><span class="line">String name &#x3D; req.getParameter(&quot;name&quot;);</span><br><span class="line">        String password &#x3D; req.getParameter(&quot;passWord&quot;);</span><br><span class="line">        System.out.println(&quot;用户名&quot; +name);</span><br><span class="line">        System.out.println(&quot;密码&quot; + password);</span><br></pre></td></tr></table></figure><ul><li><img src="/images/Servlet%E5%AD%A6%E4%B9%A0/image-20210110200936547.png"></li><li><img src="/images/Servlet%E5%AD%A6%E4%B9%A0/image-20210110200956536.png"></li><li><img src="/images/Servlet%E5%AD%A6%E4%B9%A0/image-20210110201019934.png"></li></ul><h2 id="Response响应对象"><a href="#Response响应对象" class="headerlink" title="Response响应对象"></a>Response响应对象</h2><blockquote><p>作用：HttpServletResponse接口继承自ServletResponse，因为HTTP响应包含这响应行，响应头和响应体三部分，HttpServletResponse中分别定义了发送响应行，响应头，响应体的相关方法</p></blockquote><h3 id="发送响应行"><a href="#发送响应行" class="headerlink" title="发送响应行"></a>发送响应行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.setStatus(int status) ：当Servlet向客户端回送消息的时候，需要设置一个状态码，该方法用于设置HTTP响应消息的状态码，并生成响应状态行，默认发送一个200的状态码</span><br><span class="line"></span><br><span class="line">2.sendError(int code):该方法用于发送表示错误信息的状态码，例如404</span><br><span class="line"></span><br><span class="line">3.sendErrot(int code,String errorMessage),errorMessage 可以以文本形式显示在客户端</span><br><span class="line"></span><br><span class="line">没有错误的时候用setStatus，有错误的时候用sendError</span><br></pre></td></tr></table></figure><h3 id="发送响应头"><a href="#发送响应头" class="headerlink" title="发送响应头"></a>发送响应头</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. addHeader(String name,String value): 该方法用于设置HTTP协议的相应头字段，其中name时相应头字段名，value时响应字段的值</span><br><span class="line"></span><br><span class="line">2.setHeader(String name,String value): 该方法和add相同，唯一的区别是setHeader添加一个同名的响应头字段的时候会覆盖原来的</span><br><span class="line"></span><br><span class="line">3. addIntHeader(String name,int value)</span><br><span class="line">4. setIntHeader(String name,int value) 两个方法用于将value值为int的字段加入响应头中</span><br><span class="line">5.setConentLength():该方法用于设置HTTP响应消息的内容大小，单位是字节</span><br><span class="line">6.setContentType():该方法用于设置Servlet输出内容的类型，也就是HTTP协议中的Content-Type响应头，例如发送到客户端的内容是图片需要把响应头字段的类型设置为“image&#x2F;jpg”</span><br><span class="line">7.setCharcterEncoding(String charset)</span><br></pre></td></tr></table></figure><h3 id="发送响应消息体"><a href="#发送响应消息体" class="headerlink" title="发送响应消息体"></a>发送响应消息体</h3><p>两个输出流方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.getOutputStream():该方法获取的字节流输出对象为ServletOutputStream类型，他是OutputStream的子类，因此可以直接输出字节数组中二进制数据</span><br><span class="line">        ServletOutputStream outputStream &#x3D; resp.getOutputStream();</span><br><span class="line">        outputStream.write(result.getBytes());</span><br><span class="line">        &#x2F;&#x2F;字节流必须要使用getBytes转变成字节</span><br><span class="line">2.getWrite()：该方法获得的字符输出流对象是PrintWriter类型，由于它可以直接输出文本类型，因此要输出网页文档，需要使用这个方法</span><br><span class="line">        PrintWriter writer &#x3D; resp.getWriter();</span><br><span class="line">        writer.write(result);</span><br><span class="line">        &#x2F;&#x2F;字符流可以直接输出</span><br></pre></td></tr></table></figure><blockquote><p>响应时页面出现乱码加上</p><pre><code> response.setContentType(&quot;text/html;charset=&#39;utf-8&#39;&quot;); response.setCharacterEncoding(&quot;utf-8&quot;);</code></pre></blockquote><h3 id="实验：验证码"><a href="#实验：验证码" class="headerlink" title="实验：验证码"></a>实验：验证码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(name &#x3D; &quot;VerifyCodeServlet&quot;,urlPatterns &#x3D; &quot;&#x2F;code&quot;)</span><br><span class="line">public class VerifyCodeServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        int width &#x3D; 100;</span><br><span class="line">        int height &#x3D; 30;</span><br><span class="line"></span><br><span class="line">        String data &#x3D; &quot;abcdefghijklmnopqrst0123456&quot;;</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        &#x2F;&#x2F;载入图片</span><br><span class="line">        BufferedImage image &#x3D; new BufferedImage(width,height,BufferedImage.TYPE_INT_BGR);</span><br><span class="line">        &#x2F;&#x2F;用来换背景颜色</span><br><span class="line">        Graphics graphics &#x3D; image.getGraphics();</span><br><span class="line">        &#x2F;&#x2F;设置颜色</span><br><span class="line">        graphics.setColor(Color.gray);</span><br><span class="line">        &#x2F;&#x2F;颜色覆盖</span><br><span class="line">        graphics.fillRect(0,0,width,height);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; 4 ; i++)&#123;</span><br><span class="line">            int positon &#x3D; random.nextInt(data.length());</span><br><span class="line">            String temp &#x3D; data.substring(positon,positon+1);</span><br><span class="line">            &#x2F;&#x2F;画字母，drawString(要画的字,宽,高)</span><br><span class="line">            graphics.drawString(temp,width&#x2F;5*(i+1),15);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ImageIO.write(image,&quot;jpg&quot;,response.getOutputStream());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><ul><li>Servlet接口：javax.servlet.Servlet接口<ul><li>init(ServletConfig) 方法：初始化方法</li><li>service(ServletRequest,ServletReponse)方法，每次访问都会调用来处理请求</li><li>destory()方法：销毁servlet方法</li></ul></li><li>HttpServlet接口：javax.servlet.http<ul><li>继承自Servlet接口，并重新实现了service方法，更具不同请求方式调用不同的处理方法</li><li>service(HttpServletRequest,HttpServletResponse)方法，获取请求方式，分别调用doGet()或者doPost()方法</li></ul></li><li><img src="/images/Servlet%E5%AD%A6%E4%B9%A0/image-20210113202821048.png"><ul><li>第一次执行需要init方法之后，再次接受Request请求都直接运行service方法</li><li>当服务器关闭或者项目被移除服务器，destory方法会执行，生命周期结束</li></ul></li><li>注意：Servlet实例时单例的，即无论请求多少次Servlet，最多只有一个Servlet实例，如果多个客户端并发，同时访问Servlet的时候，服务器会启动多个线程分别执行Servlet的servicec方法<ul><li>原因：如果我们多次访问都创建一个Servlet实例，会占用和浪费过多的计算机资源</li></ul></li></ul><hr><h3 id="ServletConfig对象"><a href="#ServletConfig对象" class="headerlink" title="ServletConfig对象"></a>ServletConfig对象</h3><blockquote><p>ServletConfig对象时它所对应的Servlet对象的相关配置信息</p></blockquote><p><strong>特点：</strong></p><ul><li>每一个servlet对象都有一个ServletConfig对象和它相对应</li><li>ServletConfig对象在多个Servlet对象之间时不能共享的</li></ul><p><strong>常用方法</strong>：</p><ul><li>getInitParameter(String name) 返回一个初始化变量的值</li><li>getInitParameterNames() 返回servlet初始化参数的所有名称</li><li>getServletContext()  获取ServletContext对象</li><li>getServletName()  获取Servlet的name配置值</li><li>getServletConfig()  获得一个ServletConfig对象</li></ul><p>可以在xml中的servlet中设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;hellpservlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;net.zixue.servlet.HelloServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line"></span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">    &#x2F;&#x2F;可以通过</span><br><span class="line">        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br></pre></td></tr></table></figure><p>重写init方法获取config信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void init() throws ServletException &#123;</span><br><span class="line">       super.init();</span><br><span class="line">       &#x2F;&#x2F;获取ServletConfig对象</span><br><span class="line">       ServletConfig servletConfig &#x3D;  this.getServletConfig();</span><br><span class="line">       String encoding &#x3D;  servletConfig.getInitParameter(&quot;encoding&quot;);</span><br><span class="line">       System.out.println(encoding);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h3><blockquote><p>ServletContext即Servlet上下文对象，该对象表示当前的web应用环境信息</p></blockquote><h4 id="获得项目初始化参数"><a href="#获得项目初始化参数" class="headerlink" title="获得项目初始化参数"></a>获得项目初始化参数</h4><ul><li><p>获取ServletContext对象</p><ul><li>通过ServletConfig的getServletContext()方法可以得到ServletContext对象</li><li>HttpServlet中直接通过this.getServletContext()获取</li></ul></li><li><p>域对象（域对象就是在不同资源之前来共享数据，保存数据，获取数据）</p><ul><li>ServletContext对象通常称为Context域对象</li></ul></li><li><p>获取对象方法</p><ul><li><p>在xml文件中设置初始化参数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：不在servlet内</span><br></pre></td></tr></table></figure></li><li><p>在Class文件中获取初始化参数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">    String encoing &#x3D; this.getServletContext().getInitParameter(&quot;encoding&quot;);</span><br><span class="line">    System.out.println(encoing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>获取多个初始化参数的名称</p><ul><li>Enumeration getInitParameterNames()</li></ul></li><li><p>根据名称获得初始化参数</p><ul><li>String getInitParameter(“参数名”)</li></ul></li></ul></li></ul></li></ul><h4 id="获得数据库资源"><a href="#获得数据库资源" class="headerlink" title="获得数据库资源"></a>获得数据库资源</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputStream resourceAsStream &#x3D; this.getServletContext().getResourceAsStream(&quot;&#x2F;db.properties&quot;);</span><br><span class="line">        Properties properties &#x3D; new Properties();</span><br><span class="line">        properties.load(resourceAsStream);</span><br><span class="line">        String name &#x3D; properties.getProperty(&quot;name&quot;);</span><br><span class="line">        String passWord &#x3D; properties.getProperty(&quot;passWord&quot;);</span><br><span class="line">        String url &#x3D; properties.getProperty(&quot;url&quot;);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(passWord);</span><br><span class="line">        System.out.println(url);</span><br></pre></td></tr></table></figure><ul><li><img src="/images/Servlet%E5%AD%A6%E4%B9%A0/image-20210116233146397.png"></li></ul><h4 id="在多个Servlet之间共享数据"><a href="#在多个Servlet之间共享数据" class="headerlink" title="在多个Servlet之间共享数据"></a>在多个Servlet之间共享数据</h4><ul><li>void setAttribute(String name, Object object):存放数据</li><li>Object getAttribute(String name):存取数据</li><li>void removeAttreibute(String name):删除数据</li></ul><h4 id="读取项目的资源文件"><a href="#读取项目的资源文件" class="headerlink" title="读取项目的资源文件"></a>读取项目的资源文件</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;读取文件路径返回文件流</span><br><span class="line">InputStream getResourceAsStream(&quot;根目录&quot;)</span><br><span class="line"></span><br><span class="line">InputStream resourceAsStream &#x3D; this.getServletContext().getResourceAsStream(&quot;&#x2F;db.properties&quot;);</span><br></pre></td></tr></table></figure><ul><li><p>读取配置文件方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties properties &#x3D; new Properties();</span><br><span class="line">properties.load(resourceAsStream);</span><br><span class="line">String name &#x3D; properties.getProperty(&quot;name&quot;);</span><br><span class="line">String passWord &#x3D; properties.getProperty(&quot;passWord&quot;);</span><br><span class="line">String url &#x3D; properties.getProperty(&quot;url&quot;);</span><br></pre></td></tr></table></figure><ul><li><p>load()：加载进文件流</p></li><li><p>String getProperty(String name)：获得参数</p></li></ul></li></ul><h2 id="Servlet之间的跳转"><a href="#Servlet之间的跳转" class="headerlink" title="Servlet之间的跳转"></a>Servlet之间的跳转</h2><blockquote><p>Servlet跳转技术可以把一块业务模块分开就是MVC模式</p><p>MVC模式：用一种业务逻辑、数据、界面分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中</p></blockquote><h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><ul><li><p>相关方法</p><ul><li>RequestDispatcher对象，可以通过request.getRequestDispatcher()方法获取，调用这个对象的foward方法可以实现请求转发</li></ul></li><li><p>转发过程中携带数据：</p><ul><li>request本身也是一个域对象，request可以携带数据传输给其他web资源</li><li>setAttribute</li><li>getAttribute</li><li>removeAttribute</li><li>getAttributeNames</li></ul></li><li><p>实验样例</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String userName &#x3D; &quot;xiaoming&quot;;</span><br><span class="line">        String userPass &#x3D; &quot;123456&quot;;</span><br><span class="line">        &#x2F;&#x2F;获得网页传来的参数</span><br><span class="line">        String name &#x3D; request.getParameter(&quot;name&quot;);</span><br><span class="line">        String passWord &#x3D; request.getParameter(&quot;passWord&quot;);</span><br><span class="line">        if (!name.equals(userName))&#123;</span><br><span class="line">            &#x2F;&#x2F;账户不存在</span><br><span class="line">            &#x2F;&#x2F;传递数据回jsp文件</span><br><span class="line">            request.setAttribute(&quot;errorMessage&quot;,&quot;账户不存在&quot;);</span><br><span class="line">            request.getRequestDispatcher(&quot;&#x2F;loginError.jsp&quot;).forward(request,response);</span><br><span class="line">        &#125;else if (!passWord.equals(userPass))&#123;</span><br><span class="line">            &#x2F;&#x2F;密码错误</span><br><span class="line">            request.setAttribute(&quot;errorMessage&quot;,&quot;密码错误&quot;);</span><br><span class="line">            request.getRequestDispatcher(&quot;&#x2F;loginError.jsp&quot;).forward(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jsp文件接受传递回来的数据</span><br><span class="line">&lt;%&#x3D;request.getAttribute(&quot;errorMessage&quot;)%&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><blockquote><p>重定向是根据服务器返回的状态码来实现的，客户端浏览器在请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletResponsee的setStatus(int status)方法来设置状态码。如果服务器这个时候返回的状态码是301或者302，则浏览器就会到新的网址重新请求该资源。服务器的响应会带着这个新资源的地址</p></blockquote><ul><li><p>相关代码</p><ul><li><blockquote><p>注意：如果返回的是自己创建的html文件需要加上/项目名</p></blockquote></li><li><p>设置状态码为302</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY);</span><br></pre></td></tr></table></figure></li><li><p>在请求头中携带新的资源地址</p><ul><li> response.setHeader(“Location”,”<a href="https://www.baidu.com&quot;/">https://www.baidu.com&quot;</a>);</li></ul></li><li><p>方法二</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendRedirect(String location);</span><br><span class="line">&#x2F;&#x2F;上面操作的二合一</span><br></pre></td></tr></table></figure><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4></li></ul></li><li><p>重定向的地址栏会发生变化，转发不会</p></li><li><p>重定向是两次请求两次响应，转发是一次申请一次响应</p><ul><li>重定向工作过程<ul><li>浏览器发送request请求，服务器返回response响应，同时发送状态码和url ，浏览器根据url发出request请求，服务器（servlet,jsp或者其他web资源）返回response</li></ul></li><li>请求转发工作过程<ul><li>浏览器发送request请求，服务器servlet通过forward转发到（servlet,jsp或者其他web资源）返回response</li></ul></li></ul></li><li><p>重定向路径需要加工程名，转发路径不需要加工程名</p></li><li><p>重定向可以跳转到任何网页，转发只能在服务器内部进行</p></li></ul><h4 id="自动跳转"><a href="#自动跳转" class="headerlink" title="自动跳转"></a>自动跳转</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setHeader(&quot;refresh&quot;,&quot;3&quot;);</span><br><span class="line"></span><br><span class="line">response.setHeader(&quot;refresh&quot;,&quot;3;url&#x3D;&#39;&#x2F;Hello&#x2F;home.html&#39;&quot;);</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String message &#x3D; &quot;3秒后会自动跳转到首页，如果没有跳转，请点击&lt;a href &#x3D; &#39;&#x2F;Hello&#x2F;home.html&#39;&gt;链接跳转&lt;a&gt;&quot;;</span><br><span class="line">        request.setAttribute(&quot;message&quot;,message);</span><br><span class="line">        request.getRequestDispatcher(&quot;&#x2F;index.jsp&quot;).forward(request,response);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">index.jsp文件中</span><br><span class="line">&lt;%&#x3D;request.getAttribute(&quot;message&quot;)%&gt;</span><br></pre></td></tr></table></figure><ul><li><p>JSP中实现自动刷新</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&#39;refresh&#39; content&#x3D;&#39;3;url&#x3D;&#x2F;Hello&#x2F;home.html&#39;&gt;</span><br></pre></td></tr></table></figure><ul><li><p>meta标签模仿的是一个响应头，不是请求头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String message &#x3D; &quot;&lt;meta http-equiv&#x3D;&#39;refresh&#39; content&#x3D;&#39;3;url&#x3D;&#x2F;Hello&#x2F;home.html&#39;&gt;3秒后会自动跳转到首页，如果没有跳转，请点击&lt;a href &#x3D; &#39;&#x2F;Hello&#x2F;home.html&#39;&gt;链接跳转&lt;a&gt;&quot;;</span><br><span class="line">request.setAttribute(&quot;message&quot;,message);</span><br><span class="line">request.getRequestDispatcher(&quot;&#x2F;index.jsp&quot;).forward(request,response);</span><br></pre></td></tr></table></figure><h2 id="Servlet线程安全"><a href="#Servlet线程安全" class="headerlink" title="Servlet线程安全"></a>Servlet线程安全</h2></li></ul></li><li><p>当多个客户端并发访问同一个servlet的时候，web服务器会为每一个客户端的访问创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内部如果访问了同一个共享资源（方法内的局部变量不算）的话就可能引发线程安全问题</p></li><li><p>解决方法</p><ul><li>同步代码块  //当一个线程使用时当前线程会进入阻塞状态，当线程数多的时候速度就会很慢<ul><li>synchronized(this){}</li></ul></li><li>实现SingleThreadModle接口 //已过时</li><li>尽量不要在Servlet实例中使用共享变量</li></ul></li></ul><h2 id="文件的下载操作"><a href="#文件的下载操作" class="headerlink" title="文件的下载操作"></a>文件的下载操作</h2><ul><li><p>通过文件输入输出流将文件返回给客户端浏览器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String filename &#x3D; request.getParameter(&quot;filename&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取文件的绝对路径</span><br><span class="line">        String realPath &#x3D; this.getServletContext().getRealPath(&quot;download&#x2F;&quot;+filename);</span><br><span class="line">        InputStream in &#x3D; new FileInputStream(realPath);</span><br><span class="line">        ServletOutputStream outputStream &#x3D; response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;文件拷贝</span><br><span class="line">        int len &#x3D; 0;</span><br><span class="line">        byte[] buffer &#x3D; new byte[1024];</span><br><span class="line">        while((len &#x3D; in.read(buffer)) &gt; 0)&#123;</span><br><span class="line">            outputStream.write(buffer,0,len);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br></pre></td></tr></table></figure></li><li><p>通过对应的http响应体通知浏览器下载该文件</p><ul><li><p>告知浏览器文件的类型：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(文件的MIME类型)</span><br></pre></td></tr></table></figure></li><li><p>告知浏览器文件的打开方式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responsresponse.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename&#x3D;&quot;+filename);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String filename &#x3D; request.getParameter(&quot;filename&quot;);</span><br><span class="line">        String mimeType &#x3D;  this.getServletContext().getMimeType(filename);</span><br><span class="line">        response.setContentType(mimeType);</span><br><span class="line">        response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename&#x3D;&quot;+filename);</span><br><span class="line">        &#x2F;&#x2F;获取文件的绝对路径</span><br><span class="line">        String realPath &#x3D;  this.getServletContext().getRealPath(&quot;download&#x2F;&quot;+filename);</span><br><span class="line">        InputStream in &#x3D; new FileInputStream(realPath);</span><br><span class="line">        ServletOutputStream outputStream &#x3D; response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;文件拷贝</span><br><span class="line">        int len &#x3D; 0;</span><br><span class="line">        byte[] buffer &#x3D; new byte[1024];</span><br><span class="line">        while((len &#x3D; in.read(buffer)) &gt; 0)&#123;</span><br><span class="line">            outputStream.write(buffer,0,len);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy学习</title>
      <link href="2021/01/28/numpy%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/28/numpy%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是numpy"><a href="#什么是numpy" class="headerlink" title="什么是numpy"></a>什么是numpy</h1><p>一个在Python中做科学计算的基础库，重在<strong>数值计算</strong>，也是大部分Python科学计算库的基础库，多用于大型、多维数组上执行数值运算</p><blockquote><p>import numpy as np</p></blockquote><h1 id="创建数组-矩阵"><a href="#创建数组-矩阵" class="headerlink" title="创建数组(矩阵)"></a>创建数组(矩阵)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建数组三种方法</span><br><span class="line">1. np.array([1,2,3,4,5])</span><br><span class="line">2. np.array(range(1,6))</span><br><span class="line">3. np.arange(1,6)</span><br><span class="line"></span><br><span class="line">arange使用方法</span><br><span class="line">arrange([start,] stop [,step],dtype &#x3D; None)</span><br></pre></td></tr></table></figure><h2 id="数组类名"><a href="#数组类名" class="headerlink" title="数组类名"></a>数组类名</h2><blockquote><p>numpy.ndarray</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/images/numpy%E5%AD%A6%E4%B9%A0/image-20210128160211749.png" alt="image-20210128160211749"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">指定创建数组的数据类型</span><br><span class="line">np.array([],dtype&#x3D;)</span><br><span class="line">dtype：用于设定需要的数据类型</span><br><span class="line"></span><br><span class="line">修改数组的数据类型</span><br><span class="line">数组名.astype(&quot;要修改的数据类型&quot;)</span><br><span class="line"></span><br><span class="line">修改浮点型的小数位数</span><br><span class="line">t1 &#x3D; np.array([random.random() for i in range(10)])</span><br><span class="line">t2 &#x3D; np.round(t1,2)</span><br><span class="line">#使用round方法使浮点数保留小数位</span><br></pre></td></tr></table></figure><h2 id="数组的形状"><a href="#数组的形状" class="headerlink" title="数组的形状"></a>数组的形状</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">数组名.shape</span><br><span class="line">#用于得到数组的形状维度</span><br><span class="line"></span><br><span class="line">数组名.reshape(想要的形状)</span><br><span class="line">#重新定义数组的形状</span><br><span class="line">#对本身不发生操作，会产生一个新 的数组</span><br><span class="line">np.arange(12).reshape(3,4)</span><br><span class="line"></span><br><span class="line">转换成一维数组</span><br><span class="line">数组名.reshape.(数组的大小)</span><br><span class="line">只传一个数表示一维，两个数表示二维....</span><br><span class="line"></span><br><span class="line">数组转换成一维数组</span><br><span class="line">数组名.flatten()</span><br></pre></td></tr></table></figure><h1 id="数组的计算"><a href="#数组的计算" class="headerlink" title="数组的计算"></a>数组的计算</h1><blockquote><p>对数组的计算操作，会对数组内每一个数进行计算操作</p></blockquote><ul><li><p>如果两个形状相同的数组进行计算操作则两个数组对应位置数字进行计算操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#对应位置相加</span><br><span class="line">t6 &#x3D; np.arange(100,124).reshape(4,6)</span><br><span class="line"> array([[100, 101, 102, 103, 104, 105],</span><br><span class="line">       [106, 107, 108, 109, 110, 111],</span><br><span class="line">       [112, 113, 114, 115, 116, 117],</span><br><span class="line">       [118, 119, 120, 121, 122, 123]])</span><br><span class="line">       </span><br><span class="line"> t5 &#x3D; np.arange(24).reshape(4,6)</span><br><span class="line"> array([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">       [ 6,  7,  8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15, 16, 17],</span><br><span class="line">       [18, 19, 20, 21, 22, 23]])</span><br><span class="line">t5 + t6</span><br><span class="line">array([[100, 102, 104, 106, 108, 110],</span><br><span class="line">       [112, 114, 116, 118, 120, 122],</span><br><span class="line">       [124, 126, 128, 130, 132, 134],</span><br><span class="line">       [136, 138, 140, 142, 144, 146]])</span><br></pre></td></tr></table></figure></li><li><p>两个数组维度不一样时</p><ul><li>当行维度相同时，每一行都进行操作</li><li>当列维度相同时，每一列都进行操作</li><li>如果行维度列维度都不相同时，则不能进行计算</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">t5</span><br><span class="line">array([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">       [ 6,  7,  8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15, 16, 17],</span><br><span class="line">       [18, 19, 20, 21, 22, 23]])</span><br><span class="line">      </span><br><span class="line">t7</span><br><span class="line">array([0, 1, 2, 3, 4, 5])</span><br><span class="line">t5 - t7</span><br><span class="line">array([[ 0,  0,  0,  0,  0,  0],</span><br><span class="line">       [ 6,  6,  6,  6,  6,  6],</span><br><span class="line">       [12, 12, 12, 12, 12, 12],</span><br><span class="line">       [18, 18, 18, 18, 18, 18]])</span><br><span class="line">当行维度相同时，每一行都进行操作</span><br><span class="line"></span><br><span class="line">t8</span><br><span class="line">array([[0],</span><br><span class="line">       [1],</span><br><span class="line">       [2],</span><br><span class="line">       [3]])</span><br><span class="line">      </span><br><span class="line">t5 - t8</span><br><span class="line">array([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">       [ 5,  6,  7,  8,  9, 10],</span><br><span class="line">       [10, 11, 12, 13, 14, 15],</span><br><span class="line">       [15, 16, 17, 18, 19, 20]])</span><br><span class="line">当列维度相同时，每一列都进行操作</span><br></pre></td></tr></table></figure></li></ul><h1 id="axis轴"><a href="#axis轴" class="headerlink" title="axis轴"></a>axis轴</h1><blockquote><p>在numpy中可以理解为<strong>方向</strong>，使用0，1，2…表示，对于一个一维数组，只有一个0轴，有多少维数组的话，就有多少条axis，axis从0开始算</p></blockquote><h1 id="numpy读取数据"><a href="#numpy读取数据" class="headerlink" title="numpy读取数据"></a>numpy读取数据</h1><blockquote><p>CSV:Comma-Separated Value,逗号分隔值文件</p><p>显示：表格状态</p><p>源文件：换行和逗号分隔行列的格式化文本，每一行的数据表示一条记录</p></blockquote><h2 id="np-loadtxt"><a href="#np-loadtxt" class="headerlink" title="np.loadtxt"></a><strong>np.loadtxt</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.loadtxt(fname,dtype&#x3D;np.float,delimiter&#x3D;None,skiprows&#x3D;0,usecols&#x3D;None,unpack&#x3D;False)</span><br><span class="line"></span><br><span class="line">unpack:True or False   当True时转置数组</span><br><span class="line">例:</span><br><span class="line">t1 &#x3D; np.loadtxt(us_file_path,delimiter&#x3D;&quot;,&quot;,dtype&#x3D;&quot;int&quot;)</span><br></pre></td></tr></table></figure><p><img src="/images/numpy%E5%AD%A6%E4%B9%A0/image-20210130144112735.png" alt="image-20210130144112735"></p><h2 id="numpy中的转置"><a href="#numpy中的转置" class="headerlink" title="numpy中的转置"></a>numpy中的转置</h2><blockquote><p>对于numpy中的数组来说，转置就是在对角线方向交换数据，目的也是为了更方便的去处理数据</p></blockquote><ul><li><p>transpose（）</p></li><li><p>t.T</p></li><li><p>swapaxes（）</p><ul><li>交换轴，行和列变换</li><li>t.swapaxes（0,1）</li></ul></li></ul><h1 id="numpy索引和切片"><a href="#numpy索引和切片" class="headerlink" title="numpy索引和切片"></a>numpy索引和切片</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#取行</span><br><span class="line">数组名[行号]</span><br><span class="line">t[2]</span><br><span class="line"></span><br><span class="line">#取连续多行</span><br><span class="line">数组名[start:end]</span><br><span class="line">t[2:]:取第三行到最后</span><br><span class="line"></span><br><span class="line">#取不连续的行</span><br><span class="line">数组名[[行号1,行号2,...]]</span><br><span class="line">t[[2,4,6]]</span><br><span class="line"></span><br><span class="line">#取列</span><br><span class="line">数组名[:,列号]</span><br><span class="line">数组名[:,2]：取第三列</span><br><span class="line"></span><br><span class="line">#取多行多列</span><br><span class="line">数组名[:,:] </span><br><span class="line"></span><br><span class="line">#取多个不相邻的点</span><br><span class="line">数组名[[],[]]</span><br><span class="line">t[[0,2],[0,1]] : 取到(0,0)点和(2,1)点</span><br></pre></td></tr></table></figure><h1 id="数值修改"><a href="#数值修改" class="headerlink" title="数值修改"></a>数值修改</h1><blockquote><p>通过切片修改值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">t</span><br><span class="line">array([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">       [ 6,  7,  8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15, 16, 17],</span><br><span class="line">       [18, 19, 20, 21, 22, 23]])       </span><br><span class="line"></span><br><span class="line">切片</span><br><span class="line">t[:,1]&#x3D;10</span><br><span class="line">array([[ 0, 10,  2,  3,  4,  5],</span><br><span class="line">       [ 6, 10,  8,  9, 10, 11],</span><br><span class="line">       [12, 10, 14, 15, 16, 17],</span><br><span class="line">       [18, 10, 20, 21, 22, 23]])</span><br><span class="line"></span><br><span class="line">布尔索引</span><br><span class="line">t[t&lt;10] &#x3D; 0</span><br><span class="line">array([[ 0,  0,  0,  0,  0,  0],</span><br><span class="line">       [ 0,  0,  0,  0, 10, 11],</span><br><span class="line">       [12, 13, 14, 15, 16, 17],</span><br><span class="line">       [18, 19, 20, 21, 22, 23]])</span><br></pre></td></tr></table></figure><h2 id="numpy中三元运算符"><a href="#numpy中三元运算符" class="headerlink" title="numpy中三元运算符"></a>numpy中三元运算符</h2><p><strong>np.where</strong>()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">np.where(条件,满足条件时的值,不满足条件时的值)</span><br><span class="line">array([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">       [ 6,  7,  8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15, 16, 17],</span><br><span class="line">       [18, 19, 20, 21, 22, 23]])</span><br><span class="line">       </span><br><span class="line">np.where(t &lt; 10,0,10)</span><br><span class="line">array([[ 0,  0,  0,  0,  0,  0],</span><br><span class="line">       [ 0,  0,  0,  0, 10, 10],</span><br><span class="line">       [10, 10, 10, 10, 10, 10],</span><br><span class="line">       [10, 10, 10, 10, 10, 10]])      </span><br></pre></td></tr></table></figure><h2 id="numpy中的clip-裁剪"><a href="#numpy中的clip-裁剪" class="headerlink" title="numpy中的clip(裁剪)"></a>numpy中的clip(裁剪)</h2><p><strong>数组名</strong>.<strong>clip</strong>()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t.clip(min，max)</span><br><span class="line">小于min值，都为min</span><br><span class="line">大于max值，都为max、</span><br><span class="line"></span><br><span class="line">array([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">       [ 6,  7,  8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15, 16, 17],</span><br><span class="line">       [18, 19, 20, 21, 22, 23]])</span><br><span class="line"></span><br><span class="line">t.clip(10,18)</span><br><span class="line">array([[10, 10, 10, 10, 10, 10],</span><br><span class="line">       [10, 10, 10, 10, 10, 11],</span><br><span class="line">       [12, 13, 14, 15, 16, 17],</span><br><span class="line">       [18, 18, 18, 18, 18, 18]])       </span><br></pre></td></tr></table></figure><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h2><ul><li><p>竖直拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">np.vstack((t1,t2))</span><br><span class="line"></span><br><span class="line">t1</span><br><span class="line">array([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">       [ 6,  7,  8,  9, 10, 11]])</span><br><span class="line">       </span><br><span class="line">t2  </span><br><span class="line">array([[24, 25, 26, 27, 28, 29],</span><br><span class="line">       [30, 31, 32, 33, 34, 35]])</span><br><span class="line">       </span><br><span class="line">np.vstack((t1,t2))</span><br><span class="line">array([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">       [ 6,  7,  8,  9, 10, 11],</span><br><span class="line">       [24, 25, 26, 27, 28, 29],</span><br><span class="line">       [30, 31, 32, 33, 34, 35]])</span><br></pre></td></tr></table></figure></li><li><p>水平拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.hstack(t1,t2)</span><br><span class="line"></span><br><span class="line">array([[ 0,  1,  2,  3,  4,  5, 24, 25, 26, 27, 28, 29],</span><br><span class="line">       [ 6,  7,  8,  9, 10, 11, 30, 31, 32, 33, 34, 35]])</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组的行列交换"><a href="#数组的行列交换" class="headerlink" title="数组的行列交换"></a>数组的行列交换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#行交换</span><br><span class="line">t[[1,2],:] &#x3D; t[[2,1],:]</span><br><span class="line"></span><br><span class="line">#列交换</span><br><span class="line">t[:,[0,2]] &#x3D; t[:,[2,0]]</span><br></pre></td></tr></table></figure><h2 id="获取最大值最小值"><a href="#获取最大值最小值" class="headerlink" title="获取最大值最小值"></a>获取最大值最小值</h2><ul><li>np.argmax(t)<ul><li>加上axis参数表示取指定维度的最值</li><li>np.argmax(t,axis = 0)</li></ul></li><li>np.argmin(t)</li></ul><h2 id="创建特殊数组"><a href="#创建特殊数组" class="headerlink" title="创建特殊数组"></a>创建特殊数组</h2><ul><li><p>全0的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.zeros((shape))</span><br><span class="line"></span><br><span class="line">np.zeros((3,4))</span><br></pre></td></tr></table></figure></li><li><p>全1的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.ones((shape))</span><br><span class="line"></span><br><span class="line">np.ones((3,4))</span><br></pre></td></tr></table></figure></li><li><p>对角线为1的正方形数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.eye(维度)</span><br><span class="line"></span><br><span class="line">np.eye(3)</span><br><span class="line">array([[1., 0., 0.],</span><br><span class="line">       [0., 1., 0.],</span><br><span class="line">       [0., 0., 1.]])</span><br></pre></td></tr></table></figure></li></ul><h2 id="numpy生成随机数"><a href="#numpy生成随机数" class="headerlink" title="numpy生成随机数"></a>numpy生成随机数</h2><p><img src="/images/numpy%E5%AD%A6%E4%B9%A0/image-20210130215614987.png" alt="image-20210130215614987"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.randint(10,20,(3,4))</span><br></pre></td></tr></table></figure><h1 id="numpy复制的注意点"><a href="#numpy复制的注意点" class="headerlink" title="numpy复制的注意点"></a>numpy复制的注意点</h1><ul><li>a=b,不完全赋值，a和b相互影响</li><li>a=b[:],视图操作，切片会创建新的对象a，但是a的数据完全由b保管，他们两个数据的变化是一致的，相当于a，b指向同一个数组</li><li>a = b.copy(),赋值，a和b互不影响</li></ul><h1 id="nan"><a href="#nan" class="headerlink" title="nan"></a>nan</h1><blockquote><p>nan:not a number 表示不是一个数字</p></blockquote><blockquote><p>inf:infinity，inf表示正无穷，-inf表示负无穷</p><p>当一个数字除以0时出现</p></blockquote><p>注意：nan和inf都是<strong>float</strong>类型的</p><h2 id="nan注意点"><a href="#nan注意点" class="headerlink" title="nan注意点"></a>nan注意点</h2><ul><li>两个nan是不相同的，np.nan != np.nan</li><li>判断数组中nan的个数<ul><li>np.count_nonzero(t != t)</li></ul></li><li>判断是否为nan<ul><li>np.isnan(a)：返回bool类型</li><li>将nan替换成0：t[np.isnan(t)] = 0</li></ul></li><li>nan和任何值计算都为nan</li></ul><h1 id="常用统计函数"><a href="#常用统计函数" class="headerlink" title="常用统计函数]"></a>常用统计函数]</h1><blockquote><p>默认返回多维数组的全部的统计结果,如果指定axis则返回一个当前轴上的结果</p></blockquote><ul><li><p>求和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.sum(axis &#x3D; none)</span><br><span class="line"></span><br><span class="line">axis用于选择求和的维度，默认不写则求和整个数组</span><br></pre></td></tr></table></figure></li><li><p>均值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.mean(axis &#x3D; none)</span><br></pre></td></tr></table></figure></li><li><p>中间值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.median(t,axis&#x3D;none)</span><br></pre></td></tr></table></figure></li><li><p>最大值，最小值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.max(axis &#x3D; none) &#x2F;&#x2F;最大值</span><br><span class="line">t.min(axis &#x3D; none) &#x2F;&#x2F;最小值</span><br></pre></td></tr></table></figure></li><li><p>最值差</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.ptp(t,axis &#x3D; none) &#x2F;&#x2F;最大值和最小值的差</span><br></pre></td></tr></table></figure></li><li><p>标准差</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t.std(axis &#x3D; none)</span><br><span class="line"></span><br><span class="line">标准差是一组数据平均值分散程度的一种度量。一个较大的标准差，代表大部分数值和其平均值之间差异较大；一个较小的标准差，代表这些数值较接近平均值</span><br><span class="line">反映出数据的波动稳定情况，越大表示波动越大，约不稳定</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas学习</title>
      <link href="2021/01/21/pandas%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/21/pandas%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Pandas基本概念"><a href="#Pandas基本概念" class="headerlink" title="Pandas基本概念"></a>Pandas基本概念</h1><blockquote><p>pandas 是基于Numpy的一种工具，该工具是为解决数据分析任务而创建的。</p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>pandas可以处理除数值以外的其他类型数据</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>Series 一维,带标签(索引)数组</li><li>DataFrame 二维,Series容器</li></ul><h1 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h1><blockquote><p>本质上Series对象是由两个数组组成</p><p>一个数组是index索引,另一个数组是构成对象的值values,键-&gt;值</p></blockquote><h2 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pd.Series(序列,index&#x3D;)</span><br><span class="line"></span><br><span class="line">例:pd.Series([2,6,12,15,18,20],index&#x3D;list(&quot;abcdef&quot;))</span><br><span class="line">index列表表示修改的索引</span><br><span class="line"></span><br><span class="line">可以使用字典创建</span><br><span class="line">索引是字典的键</span><br><span class="line">temp_dict &#x3D; &#123;&quot;name&quot;:&quot;wxy&quot;,&quot;age&quot;:50,&quot;sex&quot;:&quot;nv&quot;&#125;</span><br><span class="line">print(pd.Series(temp_dict))</span><br></pre></td></tr></table></figure><p>注意:重新给定其他的索引之后,如果能对上就取其值,如果不能,就为nan,同时类型转变为float,因为nan为float型</p><h2 id="Series的切片和索引"><a href="#Series的切片和索引" class="headerlink" title="Series的切片和索引"></a>Series的切片和索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">series名[&quot;索引名&quot;]   获取索引对应的值</span><br><span class="line">series名[index]  获取第index行的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以使用切片操作</span><br><span class="line">series名[::]  用于获取连续数据,操作和列表操一样</span><br><span class="line">series名[[需要的行号或者索引名]]    用于获取不连续数据</span><br><span class="line"></span><br><span class="line">布尔索引</span><br><span class="line">series名[series名 &gt; | &lt; | &#x3D; ] 选择值满足条件的数据</span><br><span class="line">例:t[t&gt;10]</span><br></pre></td></tr></table></figure><h2 id="获取索引"><a href="#获取索引" class="headerlink" title="获取索引"></a>获取索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">series.index</span><br><span class="line"></span><br><span class="line">返回pandas.core.indexes.base.Index类型</span><br><span class="line">可以遍历</span><br><span class="line">可以使用list()转换为列表</span><br></pre></td></tr></table></figure><h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">series.values</span><br><span class="line"></span><br><span class="line">返回的是numpy.ndarray类型</span><br><span class="line">可以遍历</span><br><span class="line">可以使用list()转换为列表</span><br></pre></td></tr></table></figure><h1 id="pandas读取外部数据"><a href="#pandas读取外部数据" class="headerlink" title="pandas读取外部数据"></a>pandas读取外部数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pd.read_csv(&quot;地址&quot;)</span><br><span class="line">读取csv文件数据 </span><br><span class="line"></span><br><span class="line">read_文件类型  可以在文件查看可以导入的类型</span><br><span class="line"></span><br><span class="line">导入数据库数据</span><br><span class="line">pd.read_sql(sql_sentence,connection)</span><br></pre></td></tr></table></figure><h1 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>DataFrame对象既有行索引又有列索引</p><ul><li>行索引,表明不同行,横向索引,叫index,0轴,axis = 0</li><li>列索引,表明不同列,纵向索引,叫columns,1轴,axis = 1</li></ul><h2 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(np.arange(12).reshape(3,4),index&#x3D;list(&quot;abc&quot;),columns&#x3D;list(&quot;WXYZ&quot;))</span><br><span class="line"></span><br><span class="line"> 使用dict字典创建</span><br><span class="line"> d1 &#x3D; &#123;&quot;name&quot;:[&quot;xiaoming&quot;,&quot;xiaogang&quot;],&quot;age&quot; :[20,32],&quot;tel&quot;:[10086,10010]&#125;</span><br><span class="line"> pd.DataFrame(d1)</span><br><span class="line"> </span><br><span class="line">行号是行所在的第几行</span><br><span class="line">列名则是字典的key</span><br><span class="line">有多少行取决去字典有多少对value</span><br></pre></td></tr></table></figure><h2 id="DataFrame的基础属性"><a href="#DataFrame的基础属性" class="headerlink" title="DataFrame的基础属性"></a>DataFrame的基础属性</h2><ul><li>df.shape      行数列数</li><li>df.dtypes     列数据类型</li><li>df.ndim        数据维度</li><li>df.index       行索引</li><li>df.columns  列索引</li><li>df.values      对象值,二维ndarray数组</li></ul><h2 id="DataFrame整体情况查询"><a href="#DataFrame整体情况查询" class="headerlink" title="DataFrame整体情况查询"></a>DataFrame整体情况查询</h2><ul><li>df.head()    显示头部几行,默认5行</li><li>df.tail()        显示末尾几行,默认5行</li><li>df.info          相关信息概览:行数,列数,列索引,列非空个数,列类型,内存占用</li><li>df.describe() 快速综合统计结果:计数,均值,标准差,最大值,四分位数,最小值</li></ul><h2 id="DataFrame中排序的方法"><a href="#DataFrame中排序的方法" class="headerlink" title="DataFrame中排序的方法"></a>DataFrame中排序的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by&#x3D;,ascending&#x3D;)</span><br><span class="line"></span><br><span class="line">by:选择排序依据</span><br><span class="line">ascending: True为升序 False为降序</span><br></pre></td></tr></table></figure><h2 id="DataFrame切片操作"><a href="#DataFrame切片操作" class="headerlink" title="DataFrame切片操作"></a>DataFrame切片操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">获取多少行</span><br><span class="line">方括号写数组，表示取行，对行进行操作</span><br><span class="line">df[:20]</span><br><span class="line"></span><br><span class="line">方括号写字符串，表示取列索引，对列进行操作</span><br><span class="line">获取具体某一列</span><br><span class="line">df[列名]</span><br><span class="line"></span><br><span class="line">df[:100][列名] 同时取行和列</span><br></pre></td></tr></table></figure><h3 id="df-loc：通过标签索引获取数据"><a href="#df-loc：通过标签索引获取数据" class="headerlink" title="df.loc：通过标签索引获取数据"></a>df.loc：通过标签索引获取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">df.loc[&quot;行名&quot;,“类名”]</span><br><span class="line"></span><br><span class="line">   W  X   Y   Z</span><br><span class="line">a  0  1   2   3</span><br><span class="line">b  4  5   6   7</span><br><span class="line">c  8  9  10  11</span><br><span class="line">print(t1.loc[&quot;a&quot;,&quot;Z&quot;])</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">取一行</span><br><span class="line">df.loc[“行名”,:]</span><br><span class="line"></span><br><span class="line">取一列</span><br><span class="line">df.loc[:,&quot;列名&quot;]</span><br><span class="line"></span><br><span class="line">取多行多列</span><br><span class="line">df.loc[[行名1,行名2....],[列名1.列名2.....]]</span><br><span class="line"></span><br><span class="line">闭合切片</span><br><span class="line">df.loc[&quot;a&quot;:&quot;c&quot;,&quot;w&quot;]</span><br><span class="line">能取到c行</span><br></pre></td></tr></table></figure><h3 id="df-iloc：通过位置获取数据"><a href="#df-iloc：通过位置获取数据" class="headerlink" title="df.iloc：通过位置获取数据"></a>df.iloc：通过位置获取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[第几行,第几列]</span><br><span class="line">通过下标来获取数据，从0开始</span><br><span class="line"></span><br><span class="line">支持切片操作以及取多行多列的操作</span><br><span class="line">df.[:,[2,1]]</span><br><span class="line">可以调整行和列的顺序来调整输出顺序</span><br><span class="line"></span><br><span class="line">赋值更改数据</span><br><span class="line">   W  X   Y   Z</span><br><span class="line">a  0  1   2   3</span><br><span class="line">b  4  5   6   7</span><br><span class="line">c  8  9  10  11</span><br><span class="line"></span><br><span class="line">t1.iloc[1:,:1] &#x3D; np.nan</span><br><span class="line">     W  X   Y   Z</span><br><span class="line">a  0.0  1   2   3</span><br><span class="line">b  NaN  5   6   7</span><br><span class="line">c  NaN  9  10  11</span><br></pre></td></tr></table></figure><h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df[df[“列名”] &gt; ...]</span><br><span class="line"></span><br><span class="line">&amp;且</span><br><span class="line">df[(条件1)&amp;(条件2 )]</span><br><span class="line"></span><br><span class="line">|或</span><br><span class="line">df[(条件1)|(条件2 )]</span><br><span class="line"></span><br><span class="line">注意：不同条件之间需要用括号括起来</span><br></pre></td></tr></table></figure><h3 id="pandas字符串方法"><a href="#pandas字符串方法" class="headerlink" title="pandas字符串方法"></a>pandas字符串方法</h3><p><img src="/images/pandas%E5%AD%A6%E4%B9%A0/image-20210122213019212.png" alt="1"></p><h2 id="解决行列不完全显示问题"><a href="#解决行列不完全显示问题" class="headerlink" title="解决行列不完全显示问题"></a>解决行列不完全显示问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#显示所有列</span><br><span class="line">pd.set_option(&#39;display.max_columns&#39;, None)</span><br><span class="line">#显示所有行</span><br><span class="line">pd.set_option(&#39;display.max_rows&#39;, None)</span><br><span class="line">#设置value的显示长度为100，默认为50</span><br><span class="line">pd.set_option(&#39;max_colwidth&#39;,100)</span><br></pre></td></tr></table></figure><h1 id="缺失数据处理"><a href="#缺失数据处理" class="headerlink" title="缺失数据处理"></a>缺失数据处理</h1><ul><li><p>判断数据是否为NaN    </p><ul><li>pd.isnull(df) : 判断数据是nan</li><li>pd.notnull(df)：判断数据不是nan</li></ul></li><li><p>处理方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">选中W列数据不为空的行</span><br><span class="line">df[pd.nutnull(df[&quot;W&quot;])]</span><br><span class="line"></span><br><span class="line">1.删除NaN所在的行列</span><br><span class="line">dropna(axis &#x3D; 0 m how &#x3D; &quot;any&quot; ,inplace &#x3D; False)</span><br><span class="line">how:  any 表示任意为nan删除， all表示全部为nan删除</span><br><span class="line">inplace:表示是否在原df中处理</span><br><span class="line"></span><br><span class="line">2.填充数据</span><br><span class="line">df.fillna(想要填充的数字)</span><br><span class="line"></span><br><span class="line">填充适当位置的中位值</span><br><span class="line">df.fillna(df.mean())</span><br><span class="line">mean方法会自动加入平均值,nan不参与计算 </span><br><span class="line"></span><br><span class="line">只操作其中某一列</span><br><span class="line">df[列名] &#x3D; df[列名].fillna(df[列名].mean())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">处理数据为0的情况</span><br><span class="line">df[df &#x3D;&#x3D; 0] &#x3D; np.nan</span><br></pre></td></tr></table></figure><p>不选择nan的行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data1 &#x3D; df[pd.notnull(df[&quot;original_publication_year&quot;])]</span><br></pre></td></tr></table></figure><h1 id="常用统计方法"><a href="#常用统计方法" class="headerlink" title="常用统计方法"></a>常用统计方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 1.获得平均值</span><br><span class="line"> mean()</span><br><span class="line"> </span><br><span class="line"> df[&quot;Rating&quot;].mean()</span><br><span class="line"> </span><br><span class="line"> 2.统计人数</span><br><span class="line"> 方法一</span><br><span class="line"> len(df[&quot;str&quot;].unique())</span><br><span class="line"> unique()，去重方法</span><br><span class="line"> 方法二</span><br><span class="line"> len(set(df[&quot;str&quot;].tolist()))</span><br><span class="line"> 方法三：字符串统计人数</span><br><span class="line"> 将字符串转换成列表</span><br><span class="line"> temp_actors_list &#x3D; df[&quot;Actors&quot;].str.split(&quot;,&quot;).tolist()  #[[],[],[]]</span><br><span class="line">actors_list &#x3D; [i for j in temp_actors_list for i in j]</span><br><span class="line">print(len(set(actors_list)))</span><br><span class="line"> </span><br><span class="line"> 3.最大值</span><br><span class="line"> max()</span><br><span class="line"> 4.最大值位置</span><br><span class="line"> argmax()</span><br><span class="line"> 5.最小值</span><br><span class="line"> min()</span><br><span class="line"> 6.最小值位置</span><br><span class="line"> argmin()</span><br><span class="line"> 7.中位数值</span><br><span class="line"> median()</span><br><span class="line"> 8.求列的和</span><br><span class="line"> sum()</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h1 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h1><h2 id="按行索引进行合并：join"><a href="#按行索引进行合并：join" class="headerlink" title="按行索引进行合并：join()"></a>按行索引进行合并：join()</h2><ul><li><p>默认情况下把行索引相同的数据合拼道一起</p></li><li><p>不存在的行元素 用NaN代替</p></li><li><p>如果两个DataFrame的行数不同，行数依照调用函数的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1.join(df2)</span><br><span class="line">最后行数是df1的行数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">df2 &#x3D; pd.DataFrame(np.zeros((3,3)),index&#x3D;list(&quot;ABC&quot;),columns&#x3D;list(&quot;xyz&quot;))</span><br><span class="line">df1 &#x3D; pd.DataFrame(np.ones((2,4)),index&#x3D;list(&quot;ED&quot;),columns&#x3D;list(&quot;abcd&quot;))</span><br><span class="line"></span><br><span class="line">df2 &#x3D; df2.join(df1)</span><br><span class="line">print(df2)</span><br><span class="line">     x    y    z   a   b   c   d</span><br><span class="line">A  0.0  0.0  0.0 NaN NaN NaN NaN</span><br><span class="line">B  0.0  0.0  0.0 NaN NaN NaN NaN</span><br><span class="line">C  0.0  0.0  0.0 NaN NaN NaN NaN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df2 &#x3D; pd.DataFrame(np.zeros((3,3)),index&#x3D;list(&quot;ABC&quot;),columns&#x3D;list(&quot;xyz&quot;))</span><br><span class="line">df1 &#x3D; pd.DataFrame(np.ones((2,4)),index&#x3D;list(&quot;AB&quot;),columns&#x3D;list(&quot;abcd&quot;))</span><br><span class="line"></span><br><span class="line">df2 &#x3D; df2.join(df1)</span><br><span class="line">     x    y    z    a    b    c    d</span><br><span class="line">A  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span><br><span class="line">B  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span><br><span class="line">C  0.0  0.0  0.0  NaN  NaN  NaN  NaN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;行索引不同表示不存在该行的元素所以都为NaN</span><br></pre></td></tr></table></figure></li></ul><h2 id="按列索引进行合并：merge"><a href="#按列索引进行合并：merge" class="headerlink" title="按列索引进行合并：merge()"></a>按列索引进行合并：merge()</h2><ul><li><p>默认合并方式inner，交集</p></li><li><p>outer：并集,NaN补全</p></li><li><p>left：左边为准，NaN补全</p></li><li><p>right：右边为准,NaN补全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  df1.merge(df2,on&#x3D; ,)</span><br><span class="line">  </span><br><span class="line">  on表示依据什么合并</span><br><span class="line">  left_on表示以左边的某列为准</span><br><span class="line">  right_on表示以右边的某列为准</span><br><span class="line">  </span><br><span class="line">  inner：</span><br><span class="line">  df3 &#x3D; df3.merge(df1,on&#x3D;&quot;a&quot;)</span><br><span class="line">       a    b    c    d</span><br><span class="line">  A  1.0  1.0  1.0  1.0</span><br><span class="line">  B  1.0  1.0  1.0  1.0</span><br><span class="line">     f  a  x</span><br><span class="line">  0  0  1  2</span><br><span class="line">  1  3  4  5</span><br><span class="line">  2  6  7  8</span><br><span class="line">  </span><br><span class="line">  结果</span><br><span class="line">     f  a  x    b    c    d</span><br><span class="line">  0  0  1  2  1.0  1.0  1.0</span><br><span class="line">  以a为基准，如果a相等就合并</span><br><span class="line">  </span><br><span class="line">  outer：外连接</span><br><span class="line">  df3 &#x3D; df3.merge(df1,on&#x3D;&quot;a&quot;,how&#x3D;&quot;outer&quot;)</span><br><span class="line">       f    a    x    b    c    d</span><br><span class="line">  0  0.0    1  2.0  1.0  1.0  1.0</span><br><span class="line">  1  3.0    4  5.0  NaN  NaN  NaN</span><br><span class="line">  2  6.0    7  8.0  NaN  NaN  NaN</span><br><span class="line">  3  NaN  100  NaN  1.0  1.0  1.0</span><br><span class="line">  </span><br><span class="line">  right：右连接（以被调用为基准）</span><br><span class="line">  df3 &#x3D; df3.merge(df1,on&#x3D;&quot;a&quot;,how&#x3D;&quot;right&quot;)</span><br><span class="line">       f    a    x    b    c    d</span><br><span class="line">  0  NaN  100  NaN  1.0  1.0  1.0</span><br><span class="line">  1  0.0    1  2.0  1.0  1.0  1.0</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  left：左连接（以调用者为基础）</span><br><span class="line">     f  a  x    b    c    d</span><br><span class="line">  0  0  1  2  1.0  1.0  1.0</span><br><span class="line">  1  3  4  5  NaN  NaN  NaN</span><br><span class="line">2  6  7  8  NaN  NaN  NaN</span><br></pre></td></tr></table></figure></li></ul><h1 id="分组和聚合"><a href="#分组和聚合" class="headerlink" title="分组和聚合"></a>分组和聚合</h1><h2 id="分组操作"><a href="#分组操作" class="headerlink" title="分组操作"></a>分组操作</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(by&#x3D;)</span><br><span class="line"></span><br><span class="line">by&#x3D;要分组的列名</span><br><span class="line">返回DataFrameGroupBy类型</span><br><span class="line">DataFrameGroupBy每一个元素都是一个元组</span><br><span class="line">元组里面是（索引(分组的值)，分组之后的DataFrame）</span><br><span class="line">可以进行遍历</span><br><span class="line">调用聚合方法</span><br><span class="line"></span><br><span class="line">数据按照多个条件分组</span><br><span class="line">grouped &#x3D; df.groupby(by&#x3D;[df[],df[]])</span><br><span class="line"></span><br><span class="line">获取分组之后的某一部分数据：</span><br><span class="line">df.groupby(by&#x3D;[&quot;Country&quot;,&quot;State&#x2F;Province&quot;])[&quot;Country&quot;].count()</span><br><span class="line"></span><br><span class="line">对某几列数据进行分组：</span><br><span class="line">df[&quot;Country&quot;].groupby(by&#x3D;[df[&quot;Country&quot;],df[&quot;State&#x2F;Province&quot;]]).count()</span><br><span class="line"></span><br><span class="line">数据按照多个条件分组，返回Series</span><br><span class="line">df[&quot;Country&quot;].groupby(by&#x3D;[df[&quot;Country&quot;],df[&quot;State&#x2F;Province&quot;]]).count()</span><br><span class="line"></span><br><span class="line">数据按照多个条件分组，返回DataFrame</span><br><span class="line">df[[&quot;Country&quot;]].groupby(by&#x3D;[df[&quot;Country&quot;],df[&quot;State&#x2F;Province&quot;]]).count()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="调用聚合方法"><a href="#调用聚合方法" class="headerlink" title="调用聚合方法"></a>调用聚合方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(by).count()</span><br><span class="line">所有列进行count操作</span><br><span class="line"></span><br><span class="line">df.groupby(by)[&quot;列名&quot;].count()</span><br><span class="line">指定列进行count操作</span><br><span class="line"></span><br><span class="line">df.groupby(by)[&quot;列名&quot;].mean()</span><br><span class="line">求平均值</span><br><span class="line"></span><br><span class="line">groupby(by&#x3D;[&quot;&quot;,&quot;&quot;]).count() ---&gt;返回复合索引的df</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常见聚合操作"><a href="#常见聚合操作" class="headerlink" title="常见聚合操作"></a>常见聚合操作</h3><p><img src="/images/pandas%E5%AD%A6%E4%B9%A0/image-20210126160128970.png" alt="image-20210126160128970"></p><h2 id="索引和复合索引"><a href="#索引和复合索引" class="headerlink" title="索引和复合索引"></a>索引和复合索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">简单的索引操作：</span><br><span class="line">    获取index：df.index</span><br><span class="line">    指定index ：df.index &#x3D; [&#39;x&#39;,&#39;y&#39;]</span><br><span class="line">    </span><br><span class="line">    重新设置index : df.reindex(list(&quot;abcedf&quot;))</span><br><span class="line">    如果行不存在则都为NaN</span><br><span class="line">    原本的df不变</span><br><span class="line">    </span><br><span class="line">    指定某一列作为index ：df.set_index(&quot;Country&quot;,drop&#x3D;False)</span><br><span class="line">    drop&#x3D;True：  默认删除选定的那一列</span><br><span class="line">    drop&#x3D;False：不删除选定的那一列</span><br><span class="line">    </span><br><span class="line">    返回index的唯一值：df.set_index(&quot;Country&quot;).index.unique()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="从复合索引中取值"><a href="#从复合索引中取值" class="headerlink" title="从复合索引中取值"></a>从复合索引中取值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Series </span><br><span class="line">S1[&quot;a&quot;][&quot;b&quot;]</span><br><span class="line">S1[&quot;a&quot;,&quot;b&quot;]</span><br><span class="line"></span><br><span class="line">DataFrame </span><br><span class="line">df.loc[&quot;a&quot;].loc[&quot;b&quot;]</span><br></pre></td></tr></table></figure><h3 id="从里层所以中开始选择"><a href="#从里层所以中开始选择" class="headerlink" title="从里层所以中开始选择"></a>从里层所以中开始选择</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">df.swaplevel()</span><br><span class="line">交换里外层索引的位置</span><br><span class="line">     a  b</span><br><span class="line">c d      </span><br><span class="line">y h  0  7</span><br><span class="line">  j  1  6</span><br><span class="line">  k  2  5</span><br><span class="line">t l  3  4</span><br><span class="line">  m  4  3</span><br><span class="line">  n  5  2</span><br><span class="line">  o  6  1</span><br><span class="line">使用后</span><br><span class="line">     a  b</span><br><span class="line">d c      </span><br><span class="line">h y  0  7</span><br><span class="line">j y  1  6</span><br><span class="line">k y  2  5</span><br><span class="line">l t  3  4</span><br><span class="line">m t  4  3</span><br><span class="line">n t  5  2</span><br><span class="line">o t  6  1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib学习</title>
      <link href="2021/01/19/matplotlib%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/19/matplotlib%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><blockquote><p>数据分析使用适当的方法对收集来的大量数据进行分析，帮助人们做出判断，以便采取适当行动</p></blockquote><h2 id="数据分析的流程"><a href="#数据分析的流程" class="headerlink" title="数据分析的流程"></a>数据分析的流程</h2><ul><li>提出问题</li><li>准备数据</li><li>分析数据</li><li>获得结论<ul><li>成果可视化</li><li>…..</li></ul></li></ul><hr><h1 id="Matplotlib概念"><a href="#Matplotlib概念" class="headerlink" title="Matplotlib概念"></a>Matplotlib概念</h1><blockquote><p>matplotlib:最流行的Python底层绘图库，<strong>主要做数据可视化图表</strong>，模仿MATLAB构建</p></blockquote><h2 id="为什么要学matplotlib"><a href="#为什么要学matplotlib" class="headerlink" title="为什么要学matplotlib"></a>为什么要学matplotlib</h2><ul><li>能将数据进行可视化，更直观的呈现</li><li>是数据更加客观、更具说服力</li></ul><h1 id="Matplotlib使用方法"><a href="#Matplotlib使用方法" class="headerlink" title="Matplotlib使用方法"></a>Matplotlib使用方法</h1><blockquote><p>导入pyplot模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br></pre></td></tr></table></figure><h2 id="折线图绘制"><a href="#折线图绘制" class="headerlink" title="折线图绘制"></a>折线图绘制</h2><blockquote><p>能够显示数据的变化趋势，反应事物的变化情况</p></blockquote><h3 id="绘制折现图"><a href="#绘制折现图" class="headerlink" title="绘制折现图"></a>绘制折现图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(序列1,序列2,label&#x3D;,color&#x3D;,linestyle&#x3D;&#39;&#39;,linewidth&#x3D;,alpha&#x3D;,marker&#x3D;)</span><br><span class="line"></span><br><span class="line">#color 线条颜色 ‘r&#39;:红,&#39;g&#39;:绿,&#39;b&#39;:蓝,&#39;w&#39;:白,&#39;c&#39;:青,&#39;m&#39;洋红,&#39;y:&#39;黄,&#39;k&#39;:黑</span><br><span class="line">#支持RGB十六进制形式</span><br><span class="line">#linestyle 线条风格 ’-‘:实线 , &#39;--&#39;:虚线 , &#39;-.&#39;:点划线 , &#39;:&#39;:点虚线 ， &#39;&#39;:留空或空格，无线条</span><br><span class="line">#linewidth 线条宽度</span><br><span class="line">#alpha 透明度</span><br><span class="line">#label 标签名</span><br><span class="line">#marker 标记风格</span><br><span class="line">#markerfacecolor 标记颜色</span><br><span class="line">#markersize 标记尺寸</span><br></pre></td></tr></table></figure><p><img src="/images/matplotlib%E5%AD%A6%E4%B9%A0/1.png" alt="avatar"></p><h3 id="展示图"><a href="#展示图" class="headerlink" title="展示图"></a>展示图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="设置图片大小"><a href="#设置图片大小" class="headerlink" title="设置图片大小"></a>设置图片大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize&#x3D;(宽,高),dpi&#x3D;)</span><br><span class="line"></span><br><span class="line">figsize&#x3D;():表示图片的大小</span><br><span class="line">dpi:图片的清晰程度，当图片模糊的时候可以传入dpi参数，让图片更清晰</span><br></pre></td></tr></table></figure><h3 id="保存图"><a href="#保存图" class="headerlink" title="保存图"></a>保存图</h3><blockquote><p>注意必须在绘图之后保存</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(&quot;.&#x2F;文件名.文件类型&quot;)</span><br><span class="line"></span><br><span class="line">可以保存为svg矢量图格式，放大不会有锯齿</span><br></pre></td></tr></table></figure><h3 id="设置x-y轴的刻度"><a href="#设置x-y轴的刻度" class="headerlink" title="设置x,y轴的刻度"></a>设置x,y轴的刻度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#x轴</span><br><span class="line">plt.xticks(序列)</span><br><span class="line"></span><br><span class="line">#y轴</span><br><span class="line">plt.yticks(序列)</span><br><span class="line"></span><br><span class="line">#用字符串作为刻度</span><br><span class="line">#取步长，数字和字符串一一对应，数据长度一样</span><br><span class="line">x &#x3D; range(0,120)</span><br><span class="line">y &#x3D; [random.randint(20,35) for i in range(120)]</span><br><span class="line">_xtick_labels &#x3D; [f&quot;&#123;i&#125;:&#123;j&#125;&quot; for i in range(10,12) for j in range(60)]</span><br><span class="line">plt.xticks(list(x)[::3],_xtick_labels[::3],rotation &#x3D; 270) </span><br><span class="line">#rotation旋转的度数</span><br><span class="line">#让列表x中的数据和_xticks上的数据都传入，最终会在x轴上一一对应显示</span><br><span class="line">#两组数据的长度必须一样，否则不能完全覆盖整个轴</span><br><span class="line">#使用列表的切分，每隔3个显示一个</span><br><span class="line">#为了字符串不被覆盖，使用rotation选项让字符串旋转270度显示</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置中文显示"><a href="#设置中文显示" class="headerlink" title="设置中文显示"></a>设置中文显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在代码中添加一行代码</span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]#黑体</span><br></pre></td></tr></table></figure><h3 id="设置图形信息"><a href="#设置图形信息" class="headerlink" title="设置图形信息"></a>设置图形信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#x轴的信息</span><br><span class="line">plt.xlable(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">#y轴的信息</span><br><span class="line">plt.ylable(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">#标题</span><br><span class="line">plt.title(&quot;&quot;)</span><br></pre></td></tr></table></figure><h3 id="绘制网格"><a href="#绘制网格" class="headerlink" title="绘制网格"></a>绘制网格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.grid(alpha &#x3D; ,linestyle&#x3D; )</span><br><span class="line"></span><br><span class="line">#linestyle线条风格 ’-‘:实线 , &#39;--&#39;:虚线 , &#39;-.&#39;:点划线 , &#39;:&#39;:点虚线 ， &#39;&#39;:留空或空格，无线条</span><br><span class="line"></span><br><span class="line">alpha:透明度  默认1 </span><br></pre></td></tr></table></figure><h3 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1.设置lable参数</span><br><span class="line">plt.plot(x,y1,label&#x3D;&quot;自己&quot;)</span><br><span class="line">plt.plot(x,y2,label&#x3D;&quot;同桌&quot;)</span><br><span class="line">#2.添加图例</span><br><span class="line">plt.legend(loc&#x3D;)</span><br><span class="line">#loc表示显示位置可以Ctrl+b查找</span><br><span class="line">best 0</span><br><span class="line">upper right 1</span><br><span class="line">upper left  2</span><br><span class="line">lower left  3</span><br><span class="line">lower right 4</span><br><span class="line">right       5</span><br><span class="line">center left 6</span><br><span class="line">center right7</span><br><span class="line">lower center8</span><br><span class="line">upper center9</span><br><span class="line">center      10</span><br></pre></td></tr></table></figure><h2 id="散点图绘制"><a href="#散点图绘制" class="headerlink" title="散点图绘制"></a>散点图绘制</h2><blockquote><p>判断变量之间是否存在数量关联趋势，站视离群点（分布规律）</p></blockquote><h3 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h3><blockquote><p>绘制散点图和折线图方法基本相同</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(序列1,序列2)</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]#黑体</span><br><span class="line">#3月</span><br><span class="line">y_3 &#x3D; [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23]</span><br><span class="line">#10月</span><br><span class="line">y_10 &#x3D; [26,26,28,19,21,17,16,19,18,20,20,19,22,23,17,20,21,20,22,15,11,15,5,13,17,10,11,13,12,13,6]</span><br><span class="line">#设置图的大小</span><br><span class="line">plt.figure(figsize&#x3D;(20,8),dpi&#x3D;80)</span><br><span class="line">x_10 &#x3D; range(51,82)</span><br><span class="line">x_3 &#x3D; range(1,32)</span><br><span class="line">#画出三月十月的散点图</span><br><span class="line">plt.scatter(x_3,y_3,label &#x3D; &quot;3月&quot;)</span><br><span class="line">plt.scatter(x_10,y_10,label &#x3D; &#39;10月&#39;)</span><br><span class="line">#调整x轴刻度</span><br><span class="line">_x &#x3D; list(x_3) + list(x_10)</span><br><span class="line">_xtick_labels &#x3D; [f&quot;3月&#123;i&#125;日&quot; for i in x_3]</span><br><span class="line">_xtick_labels +&#x3D; [f&quot;10月&#123;i&#125;日&quot; for i in x_3]</span><br><span class="line">#设置刻度</span><br><span class="line">plt.xticks(_x[::3],_xtick_labels[::3],rotation &#x3D; 45)</span><br><span class="line">#设置x，y轴以及标题信息</span><br><span class="line">plt.xlabel(&quot;时间&quot;)</span><br><span class="line">plt.ylabel(&quot;温度&quot;)</span><br><span class="line">plt.title(&quot;标题&quot;)</span><br><span class="line">plt.legend();</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="条形图绘制"><a href="#条形图绘制" class="headerlink" title="条形图绘制"></a>条形图绘制</h2><blockquote><p>绘制<strong>离散</strong>的数据，能够一眼看出各个数据的大小，比较数据之间的差别</p><p>多用于数量统计和频率统计</p></blockquote><h3 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.bar(序列1，序列2，width)</span><br><span class="line"></span><br><span class="line">#width:宽度</span><br></pre></td></tr></table></figure><h3 id="绘制横着的条形图"><a href="#绘制横着的条形图" class="headerlink" title="绘制横着的条形图"></a>绘制横着的条形图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.barh(序列1，序列2，height&#x3D;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;height:线条粗细</span><br></pre></td></tr></table></figure><h3 id="绘图注意点"><a href="#绘图注意点" class="headerlink" title="绘图注意点"></a>绘图注意点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#条形错开演示，需要把坐标往右移宽度大小，否则会重合</span><br><span class="line">例：</span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]#黑体</span><br><span class="line">a &#x3D; [&quot;猩球崛起3：终极之战&quot;,&quot;敦刻尔克&quot;,&quot;蜘蛛侠：英雄归来&quot;,&quot;战狼2&quot;]</span><br><span class="line">b_16 &#x3D; [15746,312,4497,319]</span><br><span class="line">b_15 &#x3D; [12357,156,2045,168]</span><br><span class="line">b_14 &#x3D; [2358,399,2358,362]</span><br><span class="line"></span><br><span class="line">#将x轴往右移动bir_width的宽度</span><br><span class="line">bir_width &#x3D; 0.2</span><br><span class="line">x_14 &#x3D; list(range(len(a)))</span><br><span class="line">x_15 &#x3D; [i + bir_width for i in x_14]</span><br><span class="line">x_16 &#x3D; [i + bir_width * 2 for i in x_14]</span><br><span class="line">plt.figure(figsize&#x3D;(20,15),dpi &#x3D; 80)</span><br><span class="line">plt.bar(x_16,b_16,width&#x3D;bir_width,label &#x3D; &quot;16日&quot;)</span><br><span class="line">plt.bar(x_15,b_15,width&#x3D;bir_width,label &#x3D; &#39;15日&#39;)</span><br><span class="line">plt.bar(x_14,b_14,width&#x3D;bir_width,label &#x3D; &#39;14日&#39;)</span><br><span class="line">plt.xticks(x_15,a)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="直方图绘制"><a href="#直方图绘制" class="headerlink" title="直方图绘制"></a>直方图绘制</h2><blockquote><p>直方图一般用于没有统计过的数据</p></blockquote><h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(序列,分组数,density&#x3D;)</span><br><span class="line"></span><br><span class="line">#组数:将数据分组，当数据在100个以内的时候，按数据多少常分为5-12组</span><br><span class="line"></span><br><span class="line">#组距:每个小组的两个端点的距离</span><br><span class="line"></span><br><span class="line">组数 &#x3D; 极差 &#x2F; 组距 &#x3D; (max(a) - min (a)) &#x2F; 组距</span><br><span class="line"></span><br><span class="line">#density &#x3D; True 表示使用比率显示</span><br></pre></td></tr></table></figure><h3 id="直方图的坐标轴"><a href="#直方图的坐标轴" class="headerlink" title="直方图的坐标轴"></a>直方图的坐标轴</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(range(min(a),max(a) + bin_width,bin_width))</span><br><span class="line">#需要在max(a)后面再加一个组距这样才能显示完全</span><br></pre></td></tr></table></figure><blockquote><p>更多图像样式网站：<a href="https://matplotlib.org/gallery/index.html">https://matplotlib.org/gallery/index.html</a></p></blockquote><blockquote><p>图表制作网站：<a href="https://echarts.apache.org/">https://echarts.apache.org/</a></p></blockquote><h2 id="使用分类变量作图"><a href="#使用分类变量作图" class="headerlink" title="使用分类变量作图"></a>使用分类变量作图</h2><blockquote><p>matplotlib允许将分类变量传递给许多绘图函数</p></blockquote><h3 id="subplot函数"><a href="#subplot函数" class="headerlink" title="subplot函数"></a>subplot函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(numRow,numCol,plotNum)</span><br><span class="line"></span><br><span class="line">numRow:表示行数</span><br><span class="line">numCol:表示列数</span><br><span class="line">plotNum:表示在numRow和numCol组成的矩阵中排第几个</span><br><span class="line"></span><br><span class="line">注意：可以省略逗号</span><br><span class="line">plt.subplot(131) 表示一行三列的矩阵中的第一个图</span><br></pre></td></tr></table></figure><h3 id="suptitle函数"><a href="#suptitle函数" class="headerlink" title="suptitle函数"></a>suptitle函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.suptitle(str)</span><br><span class="line">表示多个图的主标题</span><br></pre></td></tr></table></figure><h2 id="面向figure对象API"><a href="#面向figure对象API" class="headerlink" title="面向figure对象API"></a>面向figure对象API</h2><blockquote><p>需要新建figure对象</p><p>fig = plt.figure()</p></blockquote><h3 id="新增子图"><a href="#新增子图" class="headerlink" title="新增子图"></a>新增子图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig.add_subplot(numRow,numCol,plotNum)</span><br><span class="line"></span><br><span class="line">使用方法和subplot相似</span><br></pre></td></tr></table></figure><h3 id="新增子区域"><a href="#新增子区域" class="headerlink" title="新增子区域"></a>新增子区域</h3><blockquote><p>用于图的嵌套操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fig.add_axes([left,bottom,width,height])</span><br><span class="line"></span><br><span class="line">#figure的百分比,从figure 10%的位置开始绘制, 宽高是figure的80%</span><br><span class="line">left, bottom, width, height &#x3D; 0.1, 0.1, 0.8, 0.8</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">ax3 &#x3D; fig.add_axes([0.1,0.1,0.8,0.8])</span><br><span class="line">plt.plot([1,2,3,4],[1,4,9,16])</span><br><span class="line">ax4 &#x3D; fig.add_axes([0.72,0.72,0.16,0.16])</span><br><span class="line">plt.plot([1,2,3,4],[1,4,9,16])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="添加文本"><a href="#添加文本" class="headerlink" title="添加文本"></a>添加文本</h2><h3 id="使用text"><a href="#使用text" class="headerlink" title="使用text"></a>使用text</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.text(x,y,str)</span><br><span class="line"></span><br><span class="line">x,y是要显示位置的下标，str是要显示的文字</span><br></pre></td></tr></table></figure><h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plt.annotate()</span><br><span class="line"></span><br><span class="line">x.annotate(&#39;local max&#39;, xy&#x3D;(2, 1), xytext&#x3D;(3, 1.5),</span><br><span class="line">            arrowprops&#x3D;dict(facecolor&#x3D;&#39;black&#39;, shrink&#x3D;0.05))</span><br><span class="line">            </span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">    xy&#x3D;(横坐标，纵坐标)  箭头尖端</span><br><span class="line">    xytext&#x3D;(横坐标，纵坐标) 文字的坐标，指的是最左边的坐标</span><br><span class="line">    arrowprops&#x3D; &#123;</span><br><span class="line">        facecolor&#x3D; &#39;颜色&#39;,</span><br><span class="line">        shrink &#x3D; &#39;数字&#39; &lt;1  收缩箭头</span><br><span class="line">    &#125;</span><br><span class="line">&#39;&#39;&#39;        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal算法</title>
      <link href="2021/01/19/Kruskal%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/19/Kruskal%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><blockquote><p>用于解决最小生成树问题</p><p>最小生成树：权值最小的带权无向图</p></blockquote><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>基于贪心思想</li><li>将所有的边按照权值从小到大排列，接着按照顺序选取每条边</li><li>如果这条边的两个端点不属于同一个集合就合并，知道所有的点属于同一个集合</li><li>使用并查集合并</li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>例题：<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">https://leetcode-cn.com/problems/min-cost-to-connect-all-points/</a></p><p><img src="/images/Kruskal%E7%AE%97%E6%B3%95/Kruskal.png"></p><p>思路：</p><ul><li>题目：连接所有点的最小费用，可以从题目中得出是最小生成树问题</li><li>先创建一个Edge类，用来存储点的两个点以及它们之间的长度</li><li>创建一个并查集类</li><li>创建一个List存储所有可能存在的边</li><li>所有的边按长度从小到大排序</li><li>按顺序将n条边合并，并记录它们的长度之和</li><li>注意：如果两个端点都属于同一个连通图，那么不合并</li></ul><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minCostConnectPoints(int[][] points) &#123;</span><br><span class="line">        int n &#x3D; points.length;</span><br><span class="line">        UnionFind u &#x3D; new UnionFind(n);</span><br><span class="line">        List&lt;Edge&gt; edges &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; n ; i++)&#123;</span><br><span class="line">            for (int j &#x3D; i + 1 ; j &lt; n ; j++)&#123;</span><br><span class="line">                edges.add(new Edge(distance(points,i,j) , i , j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(edges,new Comparator&lt;Edge&gt;()&#123;</span><br><span class="line">            public int compare(Edge a,Edge b)&#123;</span><br><span class="line">                return a.len - b.len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        int ans &#x3D; 0,num &#x3D; 1;</span><br><span class="line">        for (Edge edge:edges)&#123;</span><br><span class="line">            int len &#x3D; edge.len;</span><br><span class="line">            int x &#x3D; edge.x;</span><br><span class="line">            int y &#x3D; edge.y;</span><br><span class="line">            if (u.Union(x,y))&#123;</span><br><span class="line">                ans +&#x3D; len;</span><br><span class="line">                num++;</span><br><span class="line">                if (num &#x3D;&#x3D; n) break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public int distance(int[][] points,int x,int y)&#123;</span><br><span class="line">        return Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class UnionFind&#123;</span><br><span class="line">    int parents[];</span><br><span class="line">    int rank[];</span><br><span class="line">    int n;</span><br><span class="line">    public UnionFind(int n)&#123;</span><br><span class="line">        parents &#x3D; new int[n];</span><br><span class="line">        rank &#x3D; new int[n];</span><br><span class="line">        this.n &#x3D; n;</span><br><span class="line">        Arrays.fill(rank,1);</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; n ; i++)&#123;</span><br><span class="line">            parents[i] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find(int x)&#123;</span><br><span class="line">        return parents[x] &#x3D;&#x3D; x ? x : find(parents[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean Union(int x,int y)&#123;</span><br><span class="line">        int f1 &#x3D; find(x);</span><br><span class="line">        int f2 &#x3D; find(y);</span><br><span class="line">        if (f1 &#x3D;&#x3D; f2) return false;</span><br><span class="line">        if (rank[f1] &lt; rank[f2])&#123;</span><br><span class="line">            int temp &#x3D; f1;</span><br><span class="line">            f1 &#x3D; f2;</span><br><span class="line">            f2 &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        rank[f1] +&#x3D; rank[f2];</span><br><span class="line">        parents[f2] &#x3D; f1;</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Edge&#123;</span><br><span class="line">    int len;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    public Edge(int len , int x , int y)&#123;</span><br><span class="line">        this.len &#x3D; len;</span><br><span class="line">        this.x &#x3D; x;</span><br><span class="line">        this.y &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kruskal算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集算法</title>
      <link href="2021/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="并查集算法"><a href="#并查集算法" class="headerlink" title="并查集算法"></a>并查集算法</h1><blockquote><p>用于求解不相交集合的合并问题</p></blockquote><ul><li><p>并查集又称Find_Union算法</p><ul><li><p>Find：确定元素属于哪一子集</p><ul><li>采用压缩路径的方法，递归找到该点的<strong>最终</strong>父节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int find(int x)&#123;</span><br><span class="line">return x &#x3D;&#x3D; parents[x] ? x : find(parents[x])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Union：将两个子集合并成一个子集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void Union(int x,int y)&#123;</span><br><span class="line">int find_x &#x3D; find(x);</span><br><span class="line">int find_y &#x3D; find(y);</span><br><span class="line">if (find_x &#x3D;&#x3D; find_y) return;</span><br><span class="line">parents[find_x] &#x3D; find_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>按秩合并</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public void Union(int x,int y)&#123;</span><br><span class="line">int find_x &#x3D; find(x);</span><br><span class="line">int find_y &#x3D; find(y);</span><br><span class="line">if (find_x &#x3D;&#x3D; find_y) return;</span><br><span class="line">if (rank[find_x] &lt;&#x3D; rank[find_y])</span><br><span class="line">parents[find_x] &#x3D; find_y;</span><br><span class="line">else</span><br><span class="line">parents[find_y] &#x3D; find_x;</span><br><span class="line">if (rank[find_x] &#x3D;&#x3D; rank[find_y] &amp;&amp; find_x !&#x3D; find_y)</span><br><span class="line">rank[find_y]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind&#123;</span><br><span class="line">int n;</span><br><span class="line">int[] rank;</span><br><span class="line">int[] parents;</span><br><span class="line">&#x2F;&#x2F;初始化父亲数组和秩数组</span><br><span class="line">public UnionFind(int n)&#123;</span><br><span class="line">this.n &#x3D; n;</span><br><span class="line">rank &#x3D; new int[n];</span><br><span class="line">Arrays.fill(rank,1);</span><br><span class="line">parents &#x3D; new int[n];</span><br><span class="line">for (int i &#x3D; 0 ; i &lt; n ;i++)&#123;</span><br><span class="line">parents[i] &#x3D; [i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public int find(int x)&#123;</span><br><span class="line">return parents[x] &#x3D;&#x3D; x ? x:find(parents[x]);</span><br><span class="line">&#125;</span><br><span class="line">public void Union(int x,int y)&#123;</span><br><span class="line">int find_x &#x3D; find(x);</span><br><span class="line">int find_y &#x3D; find(y);</span><br><span class="line">if (find_x &#x3D;&#x3D; find_y) return;</span><br><span class="line">if (rank[find_x] &lt;&#x3D; rank[find_y])</span><br><span class="line">parents[find_x] &#x3D; find_y;</span><br><span class="line">else</span><br><span class="line">parents[find_y] &#x3D; find_x;</span><br><span class="line">if (rank[find_x] &#x3D;&#x3D; rank[find_y] &amp;&amp; find_x !&#x3D; find_y)</span><br><span class="line">rank[find_y]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2></li><li><p>当遇到二维数组的时候，需要转换成一维数组</p></li><li><p>可以使用编号方法，id = i * 列数 + j</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑算法</title>
      <link href="2021/01/19/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/19/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="拓扑算法"><a href="#拓扑算法" class="headerlink" title="拓扑算法"></a>拓扑算法</h2><blockquote><p>适用于<strong>AOV有向无权图</strong></p></blockquote><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>找出入度为0的顶点</li><li>删除入度为0的点以及和它相关的边</li><li>重复上述步骤，直到找不到入度为0的点</li><li>如果输出顶点数小于总定点数，说明存在回路</li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><blockquote><p>BFS实现（广度优先搜索）</p></blockquote><ul><li>建立入度表，入度为0的节点入队</li><li>当队列不为空时，节点出队</li><li>出队节点的邻居入度减一</li><li>如果出队节点的邻接点入度为0，加入队列</li><li>直到队列为空</li></ul><blockquote><p>例题：<a href="https://leetcode-cn.com/problems/course-schedule/">https://leetcode-cn.com/problems/course-schedule/</a></p></blockquote><p><img src="/images/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/tuopu.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph &#x3D; new ArrayList[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建邻接表</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            graph[i] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        int[] vis &#x3D; new int[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建入度表</span><br><span class="line">        int[] info &#x3D; new int[numCourses];</span><br><span class="line">        for (int[] e:prerequisites)&#123;</span><br><span class="line">            graph[e[1]].add(e[0]);</span><br><span class="line">            info[e[0]]++;</span><br><span class="line">        &#125; </span><br><span class="line">        &#x2F;&#x2F;利用队列实现</span><br><span class="line">        Queue&lt;Integer&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;入度为0的时候入队</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            if (info[i] &#x3D;&#x3D; 0) q.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!q.isEmpty())&#123;</span><br><span class="line">            int k &#x3D; q.poll();</span><br><span class="line">            vis[k] &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F;邻接点入度-1，为0时入度</span><br><span class="line">            for (int e:graph[k])&#123;</span><br><span class="line">                if (--info[e] &#x3D;&#x3D; 0) q.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;所有点被访问过说明不存在回路，可以学完所有课程</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ;i++)&#123;</span><br><span class="line">            if (vis[i] &#x3D;&#x3D; 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DFS实现（深度优先搜索）</p></blockquote><ul><li>创建邻接表和flag数组用来判断是否访问过<ul><li>flag = 1 表示被自己访问过<ul><li>说明在本轮dfs循环中第二次被访问，说明有环，返回false</li></ul></li><li>flag = -1 被邻接点访问过<ul><li>说明其他点访问过这个点了,返回true</li></ul></li></ul></li><li>当前访问过节点i,flag[i] = 1</li><li>递归 访问当前点的邻接点</li><li>当前节点所有邻接点都遍历一遍，没有返回false，说明没有回环，flag[i] = -1</li><li>未发现环，返回true</li></ul><blockquote><p>代码实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph &#x3D; new ArrayList[numCourses];</span><br><span class="line">        int[] flag &#x3D; new int[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建邻接表</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            graph[i] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;  </span><br><span class="line">        for (int[] e:prerequisites)&#123;</span><br><span class="line">            graph[e[1]].add(e[0]);</span><br><span class="line">        &#125; </span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            if (!dfs(graph,flag,i)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean dfs(List&lt;Integer&gt;[] graph,int[] flag,int i)&#123;</span><br><span class="line">        if (flag[i] &#x3D;&#x3D; 1) return false;  &#x2F;&#x2F;说明这一轮第二次访问该点，是环路</span><br><span class="line">        if (flag[i] &#x3D;&#x3D; -1) return true; &#x2F;&#x2F;说明其他点已经访问过这个点 直接返回true就行</span><br><span class="line">        flag[i] &#x3D; 1;</span><br><span class="line">        for (int e:graph[i])&#123;</span><br><span class="line">            if (!dfs(graph,flag,e)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[i] &#x3D; -1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
