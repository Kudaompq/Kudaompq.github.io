<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pandas学习</title>
      <link href="2021/01/21/pandas%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/21/pandas%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Pandas基本概念"><a href="#Pandas基本概念" class="headerlink" title="Pandas基本概念"></a>Pandas基本概念</h1><blockquote><p>pandas 是基于Numpy的一种工具，该工具是为解决数据分析任务而创建的。</p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>pandas可以处理除数值以外的其他类型数据</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>Series 一维,带标签(索引)数组</li><li>DataFrame 二维,Series容器</li></ul><h1 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h1><blockquote><p>本质上Series对象是由两个数组组成</p><p>一个数组是index索引,另一个数组是构成对象的值values,键-&gt;值</p></blockquote><h2 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pd.Series(序列,index&#x3D;)</span><br><span class="line"></span><br><span class="line">例:pd.Series([2,6,12,15,18,20],index&#x3D;list(&quot;abcdef&quot;))</span><br><span class="line">index列表表示修改的索引</span><br><span class="line"></span><br><span class="line">可以使用字典创建</span><br><span class="line">索引是字典的键</span><br><span class="line">temp_dict &#x3D; &#123;&quot;name&quot;:&quot;wxy&quot;,&quot;age&quot;:50,&quot;sex&quot;:&quot;nv&quot;&#125;</span><br><span class="line">print(pd.Series(temp_dict))</span><br></pre></td></tr></table></figure><p>注意:重新给定其他的索引之后,如果能对上就取其值,如果不能,就为nan,同时类型转变为float,因为nan为float型</p><h2 id="Series的切片和索引"><a href="#Series的切片和索引" class="headerlink" title="Series的切片和索引"></a>Series的切片和索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">series名[&quot;索引名&quot;]   获取索引对应的值</span><br><span class="line">series名[index]  获取第index行的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以使用切片操作</span><br><span class="line">series名[::]  用于获取连续数据,操作和列表操一样</span><br><span class="line">series名[[需要的行号或者索引名]]    用于获取不连续数据</span><br><span class="line"></span><br><span class="line">布尔索引</span><br><span class="line">series名[series名 &gt; | &lt; | &#x3D; ] 选择值满足条件的数据</span><br><span class="line">例:t[t&gt;10]</span><br></pre></td></tr></table></figure><h2 id="获取索引"><a href="#获取索引" class="headerlink" title="获取索引"></a>获取索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">series.index</span><br><span class="line"></span><br><span class="line">返回pandas.core.indexes.base.Index类型</span><br><span class="line">可以遍历</span><br><span class="line">可以使用list()转换为列表</span><br></pre></td></tr></table></figure><h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">series.values</span><br><span class="line"></span><br><span class="line">返回的是numpy.ndarray类型</span><br><span class="line">可以遍历</span><br><span class="line">可以使用list()转换为列表</span><br></pre></td></tr></table></figure><h1 id="pandas读取外部数据"><a href="#pandas读取外部数据" class="headerlink" title="pandas读取外部数据"></a>pandas读取外部数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pd.read_csv(&quot;地址&quot;)</span><br><span class="line">读取csv文件数据 </span><br><span class="line"></span><br><span class="line">read_文件类型  可以在文件查看可以导入的类型</span><br><span class="line"></span><br><span class="line">导入数据库数据</span><br><span class="line">pd.read_sql(sql_sentence,connection)</span><br></pre></td></tr></table></figure><h1 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>DataFrame对象既有行索引又有列索引</p><ul><li>行索引,表明不同行,横向索引,叫index,0轴,axis = 0</li><li>列索引,表明不同列,纵向索引,叫columns,1轴,axis = 1</li></ul><h2 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(np.arange(12).reshape(3,4),index&#x3D;list(&quot;abc&quot;),columns&#x3D;list(&quot;WXYZ&quot;))</span><br><span class="line"></span><br><span class="line"> 使用dict字典创建</span><br><span class="line"> d1 &#x3D; &#123;&quot;name&quot;:[&quot;xiaoming&quot;,&quot;xiaogang&quot;],&quot;age&quot; :[20,32],&quot;tel&quot;:[10086,10010]&#125;</span><br><span class="line"> pd.DataFrame(d1)</span><br><span class="line"> </span><br><span class="line">行号是行所在的第几行</span><br><span class="line">列名则是字典的key</span><br><span class="line">有多少行取决去字典有多少对value</span><br></pre></td></tr></table></figure><h2 id="DataFrame的基础属性"><a href="#DataFrame的基础属性" class="headerlink" title="DataFrame的基础属性"></a>DataFrame的基础属性</h2><ul><li>df.shape      行数列数</li><li>df.dtypes     列数据类型</li><li>df.ndim        数据维度</li><li>df.index       行索引</li><li>df.columns  列索引</li><li>df.values      对象值,二维ndarray数组</li></ul><h2 id="DataFrame整体情况查询"><a href="#DataFrame整体情况查询" class="headerlink" title="DataFrame整体情况查询"></a>DataFrame整体情况查询</h2><ul><li>df.head()    显示头部几行,默认5行</li><li>df.tail()        显示末尾几行,默认5行</li><li>df.info          相关信息概览:行数,列数,列索引,列非空个数,列类型,内存占用</li><li>df.describe() 快速综合统计结果:计数,均值,标准差,最大值,四分位数,最小值</li></ul><h2 id="DataFrame中排序的方法"><a href="#DataFrame中排序的方法" class="headerlink" title="DataFrame中排序的方法"></a>DataFrame中排序的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by&#x3D;,ascending&#x3D;)</span><br><span class="line"></span><br><span class="line">by:选择排序依据</span><br><span class="line">ascending: True为升序 False为降序</span><br></pre></td></tr></table></figure><h2 id="DataFrame切片操作"><a href="#DataFrame切片操作" class="headerlink" title="DataFrame切片操作"></a>DataFrame切片操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">获取多少行</span><br><span class="line">方括号写数组，表示取行，对行进行操作</span><br><span class="line">df[:20]</span><br><span class="line"></span><br><span class="line">方括号写字符串，表示取列索引，对列进行操作</span><br><span class="line">获取具体某一列</span><br><span class="line">df[列名]</span><br><span class="line"></span><br><span class="line">df[:100][列名] 同时取行和列</span><br></pre></td></tr></table></figure><h3 id="df-loc：通过标签索引获取数据"><a href="#df-loc：通过标签索引获取数据" class="headerlink" title="df.loc：通过标签索引获取数据"></a>df.loc：通过标签索引获取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">df.loc[&quot;行名&quot;,“类名”]</span><br><span class="line"></span><br><span class="line">   W  X   Y   Z</span><br><span class="line">a  0  1   2   3</span><br><span class="line">b  4  5   6   7</span><br><span class="line">c  8  9  10  11</span><br><span class="line">print(t1.loc[&quot;a&quot;,&quot;Z&quot;])</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">取一行</span><br><span class="line">df.loc[“行名”,:]</span><br><span class="line"></span><br><span class="line">取一列</span><br><span class="line">df.loc[:,&quot;列名&quot;]</span><br><span class="line"></span><br><span class="line">取多行多列</span><br><span class="line">df.loc[[行名1,行名2....],[列名1.列名2.....]]</span><br><span class="line"></span><br><span class="line">闭合切片</span><br><span class="line">df.loc[&quot;a&quot;:&quot;c&quot;,&quot;w&quot;]</span><br><span class="line">能取到c行</span><br></pre></td></tr></table></figure><h3 id="df-iloc：通过位置获取数据"><a href="#df-iloc：通过位置获取数据" class="headerlink" title="df.iloc：通过位置获取数据"></a>df.iloc：通过位置获取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[第几行,第几列]</span><br><span class="line">通过下标来获取数据，从0开始</span><br><span class="line"></span><br><span class="line">支持切片操作以及取多行多列的操作</span><br><span class="line">df.[:,[2,1]]</span><br><span class="line">可以调整行和列的顺序来调整输出顺序</span><br><span class="line"></span><br><span class="line">赋值更改数据</span><br><span class="line">   W  X   Y   Z</span><br><span class="line">a  0  1   2   3</span><br><span class="line">b  4  5   6   7</span><br><span class="line">c  8  9  10  11</span><br><span class="line"></span><br><span class="line">t1.iloc[1:,:1] &#x3D; np.nan</span><br><span class="line">     W  X   Y   Z</span><br><span class="line">a  0.0  1   2   3</span><br><span class="line">b  NaN  5   6   7</span><br><span class="line">c  NaN  9  10  11</span><br></pre></td></tr></table></figure><h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df[df[“列名”] &gt; ...]</span><br><span class="line"></span><br><span class="line">&amp;且</span><br><span class="line">df[(条件1)&amp;(条件2 )]</span><br><span class="line"></span><br><span class="line">|或</span><br><span class="line">df[(条件1)|(条件2 )]</span><br><span class="line"></span><br><span class="line">注意：不同条件之间需要用括号括起来</span><br></pre></td></tr></table></figure><h3 id="pandas字符串方法"><a href="#pandas字符串方法" class="headerlink" title="pandas字符串方法"></a>pandas字符串方法</h3><p><img src="/images/pandas%E5%AD%A6%E4%B9%A0/image-20210122213019212.png" alt="1"></p><h2 id="解决行列不完全显示问题"><a href="#解决行列不完全显示问题" class="headerlink" title="解决行列不完全显示问题"></a>解决行列不完全显示问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#显示所有列</span><br><span class="line">pd.set_option(&#39;display.max_columns&#39;, None)</span><br><span class="line">#显示所有行</span><br><span class="line">pd.set_option(&#39;display.max_rows&#39;, None)</span><br><span class="line">#设置value的显示长度为100，默认为50</span><br><span class="line">pd.set_option(&#39;max_colwidth&#39;,100)</span><br></pre></td></tr></table></figure><h1 id="缺失数据处理"><a href="#缺失数据处理" class="headerlink" title="缺失数据处理"></a>缺失数据处理</h1><ul><li><p>判断数据是否为NaN    </p><ul><li>pd.isnull(df) : 判断数据是nan</li><li>pd.notnull(df)：判断数据不是nan</li></ul></li><li><p>处理方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">选中W列数据不为空的行</span><br><span class="line">df[pd.nutnull(df[&quot;W&quot;])]</span><br><span class="line"></span><br><span class="line">1.删除NaN所在的行列</span><br><span class="line">dropna(axis &#x3D; 0 m how &#x3D; &quot;any&quot; ,inplace &#x3D; False)</span><br><span class="line">how:  any 表示任意为nan删除， all表示全部为nan删除</span><br><span class="line">inplace:表示是否在原df中处理</span><br><span class="line"></span><br><span class="line">2.填充数据</span><br><span class="line">df.fillna(想要填充的数字)</span><br><span class="line"></span><br><span class="line">填充适当位置的中位值</span><br><span class="line">df.fillna(df.mean())</span><br><span class="line">mean方法会自动加入平均值,nan不参与计算 </span><br><span class="line"></span><br><span class="line">只操作其中某一列</span><br><span class="line">df[列名] &#x3D; df[列名].fillna(df[列名].mean())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">处理数据为0的情况</span><br><span class="line">df[df &#x3D;&#x3D; 0] &#x3D; np.nan</span><br></pre></td></tr></table></figure><p>不选择nan的行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data1 &#x3D; df[pd.notnull(df[&quot;original_publication_year&quot;])]</span><br></pre></td></tr></table></figure><h1 id="常用统计方法"><a href="#常用统计方法" class="headerlink" title="常用统计方法"></a>常用统计方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> 1.获得平均值</span><br><span class="line"> mean()</span><br><span class="line"> </span><br><span class="line"> df[&quot;Rating&quot;].mean()</span><br><span class="line"> </span><br><span class="line"> 2.统计人数</span><br><span class="line"> 方法一</span><br><span class="line"> len(df[&quot;str&quot;].unique())</span><br><span class="line"> unique()，去重方法</span><br><span class="line"> 方法二</span><br><span class="line"> len(set(df[&quot;str&quot;].tolist()))</span><br><span class="line"> 方法三：字符串统计人数</span><br><span class="line"> temp_actors_list &#x3D; df[&quot;Actors&quot;].str.split(&quot;,&quot;).tolist()  #[[],[],[]]</span><br><span class="line">actors_list &#x3D; [i for j in temp_actors_list for i in j]</span><br><span class="line">print(len(set(actors_list)))</span><br><span class="line"> </span><br><span class="line"> 3.最大值</span><br><span class="line"> max()</span><br><span class="line"> 4.最大值位置</span><br><span class="line"> argmax()</span><br><span class="line"> 5.最小值</span><br><span class="line"> min()</span><br><span class="line"> 6.最小值位置</span><br><span class="line"> argmin()</span><br><span class="line"> 7.中位数值</span><br><span class="line"> median()</span><br><span class="line"> 8.求列的和</span><br><span class="line"> sum()</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h1 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h1><h2 id="按行索引进行合并：join"><a href="#按行索引进行合并：join" class="headerlink" title="按行索引进行合并：join()"></a>按行索引进行合并：join()</h2><ul><li><p>默认情况下把行索引相同的数据合拼道一起</p></li><li><p>不存在的行元素 用NaN代替</p></li><li><p>如果两个DataFrame的行数不同，行数依照调用函数的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1.join(df2)</span><br><span class="line">最后行数是df1的行数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">df2 &#x3D; pd.DataFrame(np.zeros((3,3)),index&#x3D;list(&quot;ABC&quot;),columns&#x3D;list(&quot;xyz&quot;))</span><br><span class="line">df1 &#x3D; pd.DataFrame(np.ones((2,4)),index&#x3D;list(&quot;ED&quot;),columns&#x3D;list(&quot;abcd&quot;))</span><br><span class="line"></span><br><span class="line">df2 &#x3D; df2.join(df1)</span><br><span class="line">print(df2)</span><br><span class="line">     x    y    z   a   b   c   d</span><br><span class="line">A  0.0  0.0  0.0 NaN NaN NaN NaN</span><br><span class="line">B  0.0  0.0  0.0 NaN NaN NaN NaN</span><br><span class="line">C  0.0  0.0  0.0 NaN NaN NaN NaN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df2 &#x3D; pd.DataFrame(np.zeros((3,3)),index&#x3D;list(&quot;ABC&quot;),columns&#x3D;list(&quot;xyz&quot;))</span><br><span class="line">df1 &#x3D; pd.DataFrame(np.ones((2,4)),index&#x3D;list(&quot;AB&quot;),columns&#x3D;list(&quot;abcd&quot;))</span><br><span class="line"></span><br><span class="line">df2 &#x3D; df2.join(df1)</span><br><span class="line">     x    y    z    a    b    c    d</span><br><span class="line">A  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span><br><span class="line">B  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span><br><span class="line">C  0.0  0.0  0.0  NaN  NaN  NaN  NaN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;行索引不同表示不存在该行的元素所以都为NaN</span><br></pre></td></tr></table></figure></li></ul><h2 id="按列索引进行合并：merge"><a href="#按列索引进行合并：merge" class="headerlink" title="按列索引进行合并：merge()"></a>按列索引进行合并：merge()</h2><ul><li><p>默认合并方式inner，交集</p></li><li><p>outer：并集,NaN补全</p></li><li><p>left：左边为准，NaN补全</p></li><li><p>right：右边为准,NaN补全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  df1.merge(df2,on&#x3D; ,)</span><br><span class="line">  </span><br><span class="line">  on表示依据什么合并</span><br><span class="line">  left_on表示以左边的某列为准</span><br><span class="line">  right_on表示以右边的某列为准</span><br><span class="line">  </span><br><span class="line">  inner：</span><br><span class="line">  df3 &#x3D; df3.merge(df1,on&#x3D;&quot;a&quot;)</span><br><span class="line">       a    b    c    d</span><br><span class="line">  A  1.0  1.0  1.0  1.0</span><br><span class="line">  B  1.0  1.0  1.0  1.0</span><br><span class="line">     f  a  x</span><br><span class="line">  0  0  1  2</span><br><span class="line">  1  3  4  5</span><br><span class="line">  2  6  7  8</span><br><span class="line">  </span><br><span class="line">  结果</span><br><span class="line">     f  a  x    b    c    d</span><br><span class="line">  0  0  1  2  1.0  1.0  1.0</span><br><span class="line">  以a为基准，如果a相等就合并</span><br><span class="line">  </span><br><span class="line">  outer：外连接</span><br><span class="line">  df3 &#x3D; df3.merge(df1,on&#x3D;&quot;a&quot;,how&#x3D;&quot;outer&quot;)</span><br><span class="line">       f    a    x    b    c    d</span><br><span class="line">  0  0.0    1  2.0  1.0  1.0  1.0</span><br><span class="line">  1  3.0    4  5.0  NaN  NaN  NaN</span><br><span class="line">  2  6.0    7  8.0  NaN  NaN  NaN</span><br><span class="line">  3  NaN  100  NaN  1.0  1.0  1.0</span><br><span class="line">  </span><br><span class="line">  right：右连接（以被调用为基准）</span><br><span class="line">  df3 &#x3D; df3.merge(df1,on&#x3D;&quot;a&quot;,how&#x3D;&quot;right&quot;)</span><br><span class="line">       f    a    x    b    c    d</span><br><span class="line">  0  NaN  100  NaN  1.0  1.0  1.0</span><br><span class="line">  1  0.0    1  2.0  1.0  1.0  1.0</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  left：左连接（以调用者为基础）</span><br><span class="line">     f  a  x    b    c    d</span><br><span class="line">  0  0  1  2  1.0  1.0  1.0</span><br><span class="line">  1  3  4  5  NaN  NaN  NaN</span><br><span class="line">2  6  7  8  NaN  NaN  NaN</span><br></pre></td></tr></table></figure></li></ul><h1 id="分组和聚合"><a href="#分组和聚合" class="headerlink" title="分组和聚合"></a>分组和聚合</h1><h2 id="分组操作"><a href="#分组操作" class="headerlink" title="分组操作"></a>分组操作</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(by&#x3D;)</span><br><span class="line"></span><br><span class="line">by&#x3D;要分组的列名</span><br><span class="line">返回DataFrameGroupBy类型</span><br><span class="line">DataFrameGroupBy每一个元素都是一个元组</span><br><span class="line">元组里面是（索引(分组的值)，分组之后的DataFrame）</span><br><span class="line">可以进行遍历</span><br><span class="line">调用聚合方法</span><br><span class="line"></span><br><span class="line">数据按照多个条件分组</span><br><span class="line">grouped &#x3D; df.groupby(by&#x3D;[df[],df[]])</span><br><span class="line"></span><br><span class="line">获取分组之后的某一部分数据：</span><br><span class="line">df.groupby(by&#x3D;[&quot;Country&quot;,&quot;State&#x2F;Province&quot;])[&quot;Country&quot;].count()</span><br><span class="line"></span><br><span class="line">对某几列数据进行分组：</span><br><span class="line">df[&quot;Country&quot;].groupby(by&#x3D;[df[&quot;Country&quot;],df[&quot;State&#x2F;Province&quot;]]).count()</span><br><span class="line"></span><br><span class="line">数据按照多个条件分组，返回Series</span><br><span class="line">df[&quot;Country&quot;].groupby(by&#x3D;[df[&quot;Country&quot;],df[&quot;State&#x2F;Province&quot;]]).count()</span><br><span class="line"></span><br><span class="line">数据按照多个条件分组，返回DataFrame</span><br><span class="line">df[[&quot;Country&quot;]].groupby(by&#x3D;[df[&quot;Country&quot;],df[&quot;State&#x2F;Province&quot;]]).count()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="调用聚合方法"><a href="#调用聚合方法" class="headerlink" title="调用聚合方法"></a>调用聚合方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(by).count()</span><br><span class="line">所有列进行count操作</span><br><span class="line"></span><br><span class="line">df.groupby(by)[&quot;列名&quot;].count()</span><br><span class="line">指定列进行count操作</span><br><span class="line"></span><br><span class="line">df.groupby(by)[&quot;列名&quot;].mean()</span><br><span class="line">求平均值</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常见聚合操作"><a href="#常见聚合操作" class="headerlink" title="常见聚合操作"></a>常见聚合操作</h3><p><img src="/images/pandas%E5%AD%A6%E4%B9%A0/image-20210126160128970.png" alt="image-20210126160128970"></p><h2 id="索引和复合索引"><a href="#索引和复合索引" class="headerlink" title="索引和复合索引"></a>索引和复合索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">简单的索引操作：</span><br><span class="line">    获取index：df.index</span><br><span class="line">    指定index ：df.index &#x3D; [&#39;x&#39;,&#39;y&#39;]</span><br><span class="line">    </span><br><span class="line">    重新设置index : df.reindex(list(&quot;abcedf&quot;))</span><br><span class="line">    如果行不存在则都为NaN</span><br><span class="line">    原本的df不变</span><br><span class="line">    </span><br><span class="line">    指定某一列作为index ：df.set_index(&quot;Country&quot;,drop&#x3D;False)</span><br><span class="line">    drop&#x3D;True：  默认删除选定的那一列</span><br><span class="line">    drop&#x3D;False：不删除选定的那一列</span><br><span class="line">    </span><br><span class="line">    返回index的唯一值：df.set_index(&quot;Country&quot;).index.unique()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="从复合索引中取值"><a href="#从复合索引中取值" class="headerlink" title="从复合索引中取值"></a>从复合索引中取值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Series </span><br><span class="line">S1[&quot;a&quot;][&quot;b&quot;]</span><br><span class="line">S1[&quot;a&quot;,&quot;b&quot;]</span><br><span class="line"></span><br><span class="line">DataFrame </span><br><span class="line">df.loc[&quot;a&quot;].loc[&quot;b&quot;]</span><br></pre></td></tr></table></figure><h3 id="从里层所以中开始选择"><a href="#从里层所以中开始选择" class="headerlink" title="从里层所以中开始选择"></a>从里层所以中开始选择</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">df.swaplevel()</span><br><span class="line">交换里外层索引的位置</span><br><span class="line">     a  b</span><br><span class="line">c d      </span><br><span class="line">y h  0  7</span><br><span class="line">  j  1  6</span><br><span class="line">  k  2  5</span><br><span class="line">t l  3  4</span><br><span class="line">  m  4  3</span><br><span class="line">  n  5  2</span><br><span class="line">  o  6  1</span><br><span class="line">使用后</span><br><span class="line">     a  b</span><br><span class="line">d c      </span><br><span class="line">h y  0  7</span><br><span class="line">j y  1  6</span><br><span class="line">k y  2  5</span><br><span class="line">l t  3  4</span><br><span class="line">m t  4  3</span><br><span class="line">n t  5  2</span><br><span class="line">o t  6  1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib学习</title>
      <link href="2021/01/19/matplotlib%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/19/matplotlib%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><blockquote><p>数据分析使用适当的方法对收集来的大量数据进行分析，帮助人们做出判断，以便采取适当行动</p></blockquote><h2 id="数据分析的流程"><a href="#数据分析的流程" class="headerlink" title="数据分析的流程"></a>数据分析的流程</h2><ul><li>提出问题</li><li>准备数据</li><li>分析数据</li><li>获得结论<ul><li>成果可视化</li><li>…..</li></ul></li></ul><hr><h1 id="Matplotlib概念"><a href="#Matplotlib概念" class="headerlink" title="Matplotlib概念"></a>Matplotlib概念</h1><blockquote><p>matplotlib:最流行的Python底层绘图库，<strong>主要做数据可视化图表</strong>，模仿MATLAB构建</p></blockquote><h2 id="为什么要学matplotlib"><a href="#为什么要学matplotlib" class="headerlink" title="为什么要学matplotlib"></a>为什么要学matplotlib</h2><ul><li>能将数据进行可视化，更直观的呈现</li><li>是数据更加客观、更具说服力</li></ul><h1 id="Matplotlib使用方法"><a href="#Matplotlib使用方法" class="headerlink" title="Matplotlib使用方法"></a>Matplotlib使用方法</h1><blockquote><p>导入pyplot模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br></pre></td></tr></table></figure><h2 id="折线图绘制"><a href="#折线图绘制" class="headerlink" title="折线图绘制"></a>折线图绘制</h2><blockquote><p>能够显示数据的变化趋势，反应事物的变化情况</p></blockquote><h3 id="绘制折现图"><a href="#绘制折现图" class="headerlink" title="绘制折现图"></a>绘制折现图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(序列1,序列2,label&#x3D;,color&#x3D;,linestyle&#x3D;&#39;&#39;,linewidth&#x3D;,alpha&#x3D;,marker&#x3D;)</span><br><span class="line"></span><br><span class="line">#color 线条颜色 ‘r&#39;:红,&#39;g&#39;:绿,&#39;b&#39;:蓝,&#39;w&#39;:白,&#39;c&#39;:青,&#39;m&#39;洋红,&#39;y:&#39;黄,&#39;k&#39;:黑</span><br><span class="line">#支持RGB十六进制形式</span><br><span class="line">#linestyle 线条风格 ’-‘:实线 , &#39;--&#39;:虚线 , &#39;-.&#39;:点划线 , &#39;:&#39;:点虚线 ， &#39;&#39;:留空或空格，无线条</span><br><span class="line">#linewidth 线条宽度</span><br><span class="line">#alpha 透明度</span><br><span class="line">#label 标签名</span><br><span class="line">#marker 标记风格</span><br><span class="line">#markerfacecolor 标记颜色</span><br><span class="line">#markersize 标记尺寸</span><br></pre></td></tr></table></figure><p><img src="/images/matplotlib%E5%AD%A6%E4%B9%A0/1.png" alt="avatar"></p><h3 id="展示图"><a href="#展示图" class="headerlink" title="展示图"></a>展示图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="设置图片大小"><a href="#设置图片大小" class="headerlink" title="设置图片大小"></a>设置图片大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize&#x3D;(宽,高),dpi&#x3D;)</span><br><span class="line"></span><br><span class="line">figsize&#x3D;():表示图片的大小</span><br><span class="line">dpi:图片的清晰程度，当图片模糊的时候可以传入dpi参数，让图片更清晰</span><br></pre></td></tr></table></figure><h3 id="保存图"><a href="#保存图" class="headerlink" title="保存图"></a>保存图</h3><blockquote><p>注意必须在绘图之后保存</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(&quot;.&#x2F;文件名.文件类型&quot;)</span><br><span class="line"></span><br><span class="line">可以保存为svg矢量图格式，放大不会有锯齿</span><br></pre></td></tr></table></figure><h3 id="设置x-y轴的刻度"><a href="#设置x-y轴的刻度" class="headerlink" title="设置x,y轴的刻度"></a>设置x,y轴的刻度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#x轴</span><br><span class="line">plt.xticks(序列)</span><br><span class="line"></span><br><span class="line">#y轴</span><br><span class="line">plt.yticks(序列)</span><br><span class="line"></span><br><span class="line">#用字符串作为刻度</span><br><span class="line">#取步长，数字和字符串一一对应，数据长度一样</span><br><span class="line">x &#x3D; range(0,120)</span><br><span class="line">y &#x3D; [random.randint(20,35) for i in range(120)]</span><br><span class="line">_xtick_labels &#x3D; [f&quot;&#123;i&#125;:&#123;j&#125;&quot; for i in range(10,12) for j in range(60)]</span><br><span class="line">plt.xticks(list(x)[::3],_xtick_labels[::3],rotation &#x3D; 270) </span><br><span class="line">#rotation旋转的度数</span><br><span class="line">#让列表x中的数据和_xticks上的数据都传入，最终会在x轴上一一对应显示</span><br><span class="line">#两组数据的长度必须一样，否则不能完全覆盖整个轴</span><br><span class="line">#使用列表的切分，每隔3个显示一个</span><br><span class="line">#为了字符串不被覆盖，使用rotation选项让字符串旋转270度显示</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置中文显示"><a href="#设置中文显示" class="headerlink" title="设置中文显示"></a>设置中文显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在代码中添加一行代码</span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]#黑体</span><br></pre></td></tr></table></figure><h3 id="设置图形信息"><a href="#设置图形信息" class="headerlink" title="设置图形信息"></a>设置图形信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#x轴的信息</span><br><span class="line">plt.xlable(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">#y轴的信息</span><br><span class="line">plt.ylable(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">#标题</span><br><span class="line">plt.title(&quot;&quot;)</span><br></pre></td></tr></table></figure><h3 id="绘制网格"><a href="#绘制网格" class="headerlink" title="绘制网格"></a>绘制网格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.grid(alpha &#x3D; ,linestyle&#x3D; )</span><br><span class="line"></span><br><span class="line">#linestyle线条风格 ’-‘:实线 , &#39;--&#39;:虚线 , &#39;-.&#39;:点划线 , &#39;:&#39;:点虚线 ， &#39;&#39;:留空或空格，无线条</span><br><span class="line"></span><br><span class="line">alpha:透明度  默认1 </span><br></pre></td></tr></table></figure><h3 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1.设置lable参数</span><br><span class="line">plt.plot(x,y1,label&#x3D;&quot;自己&quot;)</span><br><span class="line">plt.plot(x,y2,label&#x3D;&quot;同桌&quot;)</span><br><span class="line">#2.添加图例</span><br><span class="line">plt.legend(loc&#x3D;)</span><br><span class="line">#loc表示显示位置可以Ctrl+b查找</span><br><span class="line">best 0</span><br><span class="line">upper right 1</span><br><span class="line">upper left  2</span><br><span class="line">lower left  3</span><br><span class="line">lower right 4</span><br><span class="line">right       5</span><br><span class="line">center left 6</span><br><span class="line">center right7</span><br><span class="line">lower center8</span><br><span class="line">upper center9</span><br><span class="line">center      10</span><br></pre></td></tr></table></figure><h2 id="散点图绘制"><a href="#散点图绘制" class="headerlink" title="散点图绘制"></a>散点图绘制</h2><blockquote><p>判断变量之间是否存在数量关联趋势，站视离群点（分布规律）</p></blockquote><h3 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h3><blockquote><p>绘制散点图和折线图方法基本相同</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(序列1,序列2)</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]#黑体</span><br><span class="line">#3月</span><br><span class="line">y_3 &#x3D; [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23]</span><br><span class="line">#10月</span><br><span class="line">y_10 &#x3D; [26,26,28,19,21,17,16,19,18,20,20,19,22,23,17,20,21,20,22,15,11,15,5,13,17,10,11,13,12,13,6]</span><br><span class="line">#设置图的大小</span><br><span class="line">plt.figure(figsize&#x3D;(20,8),dpi&#x3D;80)</span><br><span class="line">x_10 &#x3D; range(51,82)</span><br><span class="line">x_3 &#x3D; range(1,32)</span><br><span class="line">#画出三月十月的散点图</span><br><span class="line">plt.scatter(x_3,y_3,label &#x3D; &quot;3月&quot;)</span><br><span class="line">plt.scatter(x_10,y_10,label &#x3D; &#39;10月&#39;)</span><br><span class="line">#调整x轴刻度</span><br><span class="line">_x &#x3D; list(x_3) + list(x_10)</span><br><span class="line">_xtick_labels &#x3D; [f&quot;3月&#123;i&#125;日&quot; for i in x_3]</span><br><span class="line">_xtick_labels +&#x3D; [f&quot;10月&#123;i&#125;日&quot; for i in x_3]</span><br><span class="line">#设置刻度</span><br><span class="line">plt.xticks(_x[::3],_xtick_labels[::3],rotation &#x3D; 45)</span><br><span class="line">#设置x，y轴以及标题信息</span><br><span class="line">plt.xlabel(&quot;时间&quot;)</span><br><span class="line">plt.ylabel(&quot;温度&quot;)</span><br><span class="line">plt.title(&quot;标题&quot;)</span><br><span class="line">plt.legend();</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="条形图绘制"><a href="#条形图绘制" class="headerlink" title="条形图绘制"></a>条形图绘制</h2><blockquote><p>绘制<strong>离散</strong>的数据，能够一眼看出各个数据的大小，比较数据之间的差别</p><p>多用于数量统计和频率统计</p></blockquote><h3 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.bar(序列1，序列2，width)</span><br><span class="line"></span><br><span class="line">#width:宽度</span><br></pre></td></tr></table></figure><h3 id="绘制横着的条形图"><a href="#绘制横着的条形图" class="headerlink" title="绘制横着的条形图"></a>绘制横着的条形图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.barh(序列1，序列2，height&#x3D;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;height:线条粗细</span><br></pre></td></tr></table></figure><h3 id="绘图注意点"><a href="#绘图注意点" class="headerlink" title="绘图注意点"></a>绘图注意点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#条形错开演示，需要把坐标往右移宽度大小，否则会重合</span><br><span class="line">例：</span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]#黑体</span><br><span class="line">a &#x3D; [&quot;猩球崛起3：终极之战&quot;,&quot;敦刻尔克&quot;,&quot;蜘蛛侠：英雄归来&quot;,&quot;战狼2&quot;]</span><br><span class="line">b_16 &#x3D; [15746,312,4497,319]</span><br><span class="line">b_15 &#x3D; [12357,156,2045,168]</span><br><span class="line">b_14 &#x3D; [2358,399,2358,362]</span><br><span class="line"></span><br><span class="line">#将x轴往右移动bir_width的宽度</span><br><span class="line">bir_width &#x3D; 0.2</span><br><span class="line">x_14 &#x3D; list(range(len(a)))</span><br><span class="line">x_15 &#x3D; [i + bir_width for i in x_14]</span><br><span class="line">x_16 &#x3D; [i + bir_width * 2 for i in x_14]</span><br><span class="line">plt.figure(figsize&#x3D;(20,15),dpi &#x3D; 80)</span><br><span class="line">plt.bar(x_16,b_16,width&#x3D;bir_width,label &#x3D; &quot;16日&quot;)</span><br><span class="line">plt.bar(x_15,b_15,width&#x3D;bir_width,label &#x3D; &#39;15日&#39;)</span><br><span class="line">plt.bar(x_14,b_14,width&#x3D;bir_width,label &#x3D; &#39;14日&#39;)</span><br><span class="line">plt.xticks(x_15,a)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="直方图绘制"><a href="#直方图绘制" class="headerlink" title="直方图绘制"></a>直方图绘制</h2><blockquote><p>直方图一般用于没有统计过的数据</p></blockquote><h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(序列,分组数,density&#x3D;)</span><br><span class="line"></span><br><span class="line">#组数:将数据分组，当数据在100个以内的时候，按数据多少常分为5-12组</span><br><span class="line"></span><br><span class="line">#组距:每个小组的两个端点的距离</span><br><span class="line"></span><br><span class="line">组数 &#x3D; 极差 &#x2F; 组距 &#x3D; (max(a) - min (a)) &#x2F; 组距</span><br><span class="line"></span><br><span class="line">#density &#x3D; True 表示使用比率显示</span><br></pre></td></tr></table></figure><h3 id="直方图的坐标轴"><a href="#直方图的坐标轴" class="headerlink" title="直方图的坐标轴"></a>直方图的坐标轴</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(range(min(a),max(a) + bin_width,bin_width))</span><br><span class="line">#需要在max(a)后面再加一个组距这样才能显示完全</span><br></pre></td></tr></table></figure><blockquote><p>更多图像样式网站：<a href="https://matplotlib.org/gallery/index.html">https://matplotlib.org/gallery/index.html</a></p></blockquote><blockquote><p>图表制作网站：<a href="https://echarts.apache.org/">https://echarts.apache.org/</a></p></blockquote><h2 id="使用分类变量作图"><a href="#使用分类变量作图" class="headerlink" title="使用分类变量作图"></a>使用分类变量作图</h2><blockquote><p>matplotlib允许将分类变量传递给许多绘图函数</p></blockquote><h3 id="subplot函数"><a href="#subplot函数" class="headerlink" title="subplot函数"></a>subplot函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(numRow,numCol,plotNum)</span><br><span class="line"></span><br><span class="line">numRow:表示行数</span><br><span class="line">numCol:表示列数</span><br><span class="line">plotNum:表示在numRow和numCol组成的矩阵中排第几个</span><br><span class="line"></span><br><span class="line">注意：可以省略逗号</span><br><span class="line">plt.subplot(131) 表示一行三列的矩阵中的第一个图</span><br></pre></td></tr></table></figure><h3 id="suptitle函数"><a href="#suptitle函数" class="headerlink" title="suptitle函数"></a>suptitle函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.suptitle(str)</span><br><span class="line">表示多个图的主标题</span><br></pre></td></tr></table></figure><h2 id="面向figure对象API"><a href="#面向figure对象API" class="headerlink" title="面向figure对象API"></a>面向figure对象API</h2><blockquote><p>需要新建figure对象</p><p>fig = plt.figure()</p></blockquote><h3 id="新增子图"><a href="#新增子图" class="headerlink" title="新增子图"></a>新增子图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig.add_subplot(numRow,numCol,plotNum)</span><br><span class="line"></span><br><span class="line">使用方法和subplot相似</span><br></pre></td></tr></table></figure><h3 id="新增子区域"><a href="#新增子区域" class="headerlink" title="新增子区域"></a>新增子区域</h3><blockquote><p>用于图的嵌套操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fig.add_axes([left,bottom,width,height])</span><br><span class="line"></span><br><span class="line">#figure的百分比,从figure 10%的位置开始绘制, 宽高是figure的80%</span><br><span class="line">left, bottom, width, height &#x3D; 0.1, 0.1, 0.8, 0.8</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">ax3 &#x3D; fig.add_axes([0.1,0.1,0.8,0.8])</span><br><span class="line">plt.plot([1,2,3,4],[1,4,9,16])</span><br><span class="line">ax4 &#x3D; fig.add_axes([0.72,0.72,0.16,0.16])</span><br><span class="line">plt.plot([1,2,3,4],[1,4,9,16])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="添加文本"><a href="#添加文本" class="headerlink" title="添加文本"></a>添加文本</h2><h3 id="使用text"><a href="#使用text" class="headerlink" title="使用text"></a>使用text</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.text(x,y,str)</span><br><span class="line"></span><br><span class="line">x,y是要显示位置的下标，str是要显示的文字</span><br></pre></td></tr></table></figure><h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plt.annotate()</span><br><span class="line"></span><br><span class="line">x.annotate(&#39;local max&#39;, xy&#x3D;(2, 1), xytext&#x3D;(3, 1.5),</span><br><span class="line">            arrowprops&#x3D;dict(facecolor&#x3D;&#39;black&#39;, shrink&#x3D;0.05))</span><br><span class="line">            </span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">    xy&#x3D;(横坐标，纵坐标)  箭头尖端</span><br><span class="line">    xytext&#x3D;(横坐标，纵坐标) 文字的坐标，指的是最左边的坐标</span><br><span class="line">    arrowprops&#x3D; &#123;</span><br><span class="line">        facecolor&#x3D; &#39;颜色&#39;,</span><br><span class="line">        shrink &#x3D; &#39;数字&#39; &lt;1  收缩箭头</span><br><span class="line">    &#125;</span><br><span class="line">&#39;&#39;&#39;        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal算法</title>
      <link href="2021/01/19/Kruskal%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/19/Kruskal%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><blockquote><p>用于解决最小生成树问题</p><p>最小生成树：权值最小的带权无向图</p></blockquote><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>基于贪心思想</li><li>将所有的边按照权值从小到大排列，接着按照顺序选取每条边</li><li>如果这条边的两个端点不属于同一个集合就合并，知道所有的点属于同一个集合</li><li>使用并查集合并</li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>例题：<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">https://leetcode-cn.com/problems/min-cost-to-connect-all-points/</a></p><p><img src="/images/Kruskal%E7%AE%97%E6%B3%95/Kruskal.png"></p><p>思路：</p><ul><li>题目：连接所有点的最小费用，可以从题目中得出是最小生成树问题</li><li>先创建一个Edge类，用来存储点的两个点以及它们之间的长度</li><li>创建一个并查集类</li><li>创建一个List存储所有可能存在的边</li><li>所有的边按长度从小到大排序</li><li>按顺序将n条边合并，并记录它们的长度之和</li><li>注意：如果两个端点都属于同一个连通图，那么不合并</li></ul><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minCostConnectPoints(int[][] points) &#123;</span><br><span class="line">        int n &#x3D; points.length;</span><br><span class="line">        UnionFind u &#x3D; new UnionFind(n);</span><br><span class="line">        List&lt;Edge&gt; edges &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; n ; i++)&#123;</span><br><span class="line">            for (int j &#x3D; i + 1 ; j &lt; n ; j++)&#123;</span><br><span class="line">                edges.add(new Edge(distance(points,i,j) , i , j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(edges,new Comparator&lt;Edge&gt;()&#123;</span><br><span class="line">            public int compare(Edge a,Edge b)&#123;</span><br><span class="line">                return a.len - b.len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        int ans &#x3D; 0,num &#x3D; 1;</span><br><span class="line">        for (Edge edge:edges)&#123;</span><br><span class="line">            int len &#x3D; edge.len;</span><br><span class="line">            int x &#x3D; edge.x;</span><br><span class="line">            int y &#x3D; edge.y;</span><br><span class="line">            if (u.Union(x,y))&#123;</span><br><span class="line">                ans +&#x3D; len;</span><br><span class="line">                num++;</span><br><span class="line">                if (num &#x3D;&#x3D; n) break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public int distance(int[][] points,int x,int y)&#123;</span><br><span class="line">        return Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class UnionFind&#123;</span><br><span class="line">    int parents[];</span><br><span class="line">    int rank[];</span><br><span class="line">    int n;</span><br><span class="line">    public UnionFind(int n)&#123;</span><br><span class="line">        parents &#x3D; new int[n];</span><br><span class="line">        rank &#x3D; new int[n];</span><br><span class="line">        this.n &#x3D; n;</span><br><span class="line">        Arrays.fill(rank,1);</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; n ; i++)&#123;</span><br><span class="line">            parents[i] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find(int x)&#123;</span><br><span class="line">        return parents[x] &#x3D;&#x3D; x ? x : find(parents[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean Union(int x,int y)&#123;</span><br><span class="line">        int f1 &#x3D; find(x);</span><br><span class="line">        int f2 &#x3D; find(y);</span><br><span class="line">        if (f1 &#x3D;&#x3D; f2) return false;</span><br><span class="line">        if (rank[f1] &lt; rank[f2])&#123;</span><br><span class="line">            int temp &#x3D; f1;</span><br><span class="line">            f1 &#x3D; f2;</span><br><span class="line">            f2 &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        rank[f1] +&#x3D; rank[f2];</span><br><span class="line">        parents[f2] &#x3D; f1;</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Edge&#123;</span><br><span class="line">    int len;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    public Edge(int len , int x , int y)&#123;</span><br><span class="line">        this.len &#x3D; len;</span><br><span class="line">        this.x &#x3D; x;</span><br><span class="line">        this.y &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kruskal算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集算法</title>
      <link href="2021/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="并查集算法"><a href="#并查集算法" class="headerlink" title="并查集算法"></a>并查集算法</h2><blockquote><p>用于求解不相交集合的合并问题</p></blockquote><ul><li><p>并查集又称Find_Union算法</p><ul><li><p>Find：确定元素属于哪一子集</p><ul><li>采用压缩路径的方法，递归找到该点的<strong>最终</strong>父节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int find(int x)&#123;</span><br><span class="line">return x &#x3D;&#x3D; parents[x] ? x : find(parents[x])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Union：将两个子集合并成一个子集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void Union(int x,int y)&#123;</span><br><span class="line">int find_x &#x3D; find(x);</span><br><span class="line">int find_y &#x3D; find(y);</span><br><span class="line">if (find_x &#x3D;&#x3D; find_y) return;</span><br><span class="line">parents[find_x] &#x3D; find_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>按秩合并</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public void Union(int x,int y)&#123;</span><br><span class="line">int find_x &#x3D; find(x);</span><br><span class="line">int find_y &#x3D; find(y);</span><br><span class="line">if (find_x &#x3D;&#x3D; find_y) return;</span><br><span class="line">if (rank[find_x] &lt;&#x3D; rank[find_y])</span><br><span class="line">parents[find_x] &#x3D; find_y;</span><br><span class="line">else</span><br><span class="line">parents[find_y] &#x3D; find_x;</span><br><span class="line">if (rank[find_x] &#x3D;&#x3D; rank[find_y] &amp;&amp; find_x !&#x3D; find_y)</span><br><span class="line">rank[find_y]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind&#123;</span><br><span class="line">int n;</span><br><span class="line">int[] rank;</span><br><span class="line">int[] parents;</span><br><span class="line">&#x2F;&#x2F;初始化父亲数组和秩数组</span><br><span class="line">public UnionFind(int n)&#123;</span><br><span class="line">this.n &#x3D; n;</span><br><span class="line">rank &#x3D; new int[n];</span><br><span class="line">Arrays.fill(rank,1);</span><br><span class="line">parents &#x3D; new int[n];</span><br><span class="line">for (int i &#x3D; 0 ; i &lt; n ;i++)&#123;</span><br><span class="line">parents[i] &#x3D; [i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public int find(int x)&#123;</span><br><span class="line">return parents[x] &#x3D;&#x3D; x ? x:find(parents[x]);</span><br><span class="line">&#125;</span><br><span class="line">public void Union(int x,int y)&#123;</span><br><span class="line">int find_x &#x3D; find(x);</span><br><span class="line">int find_y &#x3D; find(y);</span><br><span class="line">if (find_x &#x3D;&#x3D; find_y) return;</span><br><span class="line">if (rank[find_x] &lt;&#x3D; rank[find_y])</span><br><span class="line">parents[find_x] &#x3D; find_y;</span><br><span class="line">else</span><br><span class="line">parents[find_y] &#x3D; find_x;</span><br><span class="line">if (rank[find_x] &#x3D;&#x3D; rank[find_y] &amp;&amp; find_x !&#x3D; find_y)</span><br><span class="line">rank[find_y]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑算法</title>
      <link href="2021/01/19/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/19/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="拓扑算法"><a href="#拓扑算法" class="headerlink" title="拓扑算法"></a>拓扑算法</h2><blockquote><p>适用于<strong>AOV有向无权图</strong></p></blockquote><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>找出入度为0的顶点</li><li>删除入度为0的点以及和它相关的边</li><li>重复上述步骤，直到找不到入度为0的点</li><li>如果输出顶点数小于总定点数，说明存在回路</li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><blockquote><p>BFS实现（广度优先搜索）</p></blockquote><ul><li>建立入度表，入度为0的节点入队</li><li>当队列不为空时，节点出队</li><li>出队节点的邻居入度减一</li><li>如果出队节点的邻接点入度为0，加入队列</li><li>直到队列为空</li></ul><blockquote><p>例题：<a href="https://leetcode-cn.com/problems/course-schedule/">https://leetcode-cn.com/problems/course-schedule/</a></p></blockquote><p><img src="/images/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/tuopu.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph &#x3D; new ArrayList[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建邻接表</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            graph[i] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        int[] vis &#x3D; new int[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建入度表</span><br><span class="line">        int[] info &#x3D; new int[numCourses];</span><br><span class="line">        for (int[] e:prerequisites)&#123;</span><br><span class="line">            graph[e[1]].add(e[0]);</span><br><span class="line">            info[e[0]]++;</span><br><span class="line">        &#125; </span><br><span class="line">        &#x2F;&#x2F;利用队列实现</span><br><span class="line">        Queue&lt;Integer&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;入度为0的时候入队</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            if (info[i] &#x3D;&#x3D; 0) q.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!q.isEmpty())&#123;</span><br><span class="line">            int k &#x3D; q.poll();</span><br><span class="line">            vis[k] &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F;邻接点入度-1，为0时入度</span><br><span class="line">            for (int e:graph[k])&#123;</span><br><span class="line">                if (--info[e] &#x3D;&#x3D; 0) q.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;所有点被访问过说明不存在回路，可以学完所有课程</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ;i++)&#123;</span><br><span class="line">            if (vis[i] &#x3D;&#x3D; 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DFS实现（深度优先搜索）</p></blockquote><ul><li>创建邻接表和flag数组用来判断是否访问过<ul><li>flag = 1 表示被自己访问过<ul><li>说明在本轮dfs循环中第二次被访问，说明有环，返回false</li></ul></li><li>flag = -1 被邻接点访问过<ul><li>说明其他点访问过这个点了,返回true</li></ul></li></ul></li><li>当前访问过节点i,flag[i] = 1</li><li>递归 访问当前点的邻接点</li><li>当前节点所有邻接点都遍历一遍，没有返回false，说明没有回环，flag[i] = -1</li><li>未发现环，返回true</li></ul><blockquote><p>代码实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph &#x3D; new ArrayList[numCourses];</span><br><span class="line">        int[] flag &#x3D; new int[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建邻接表</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            graph[i] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;  </span><br><span class="line">        for (int[] e:prerequisites)&#123;</span><br><span class="line">            graph[e[1]].add(e[0]);</span><br><span class="line">        &#125; </span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            if (!dfs(graph,flag,i)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean dfs(List&lt;Integer&gt;[] graph,int[] flag,int i)&#123;</span><br><span class="line">        if (flag[i] &#x3D;&#x3D; 1) return false;  &#x2F;&#x2F;说明这一轮第二次访问该点，是环路</span><br><span class="line">        if (flag[i] &#x3D;&#x3D; -1) return true; &#x2F;&#x2F;说明其他点已经访问过这个点 直接返回true就行</span><br><span class="line">        flag[i] &#x3D; 1;</span><br><span class="line">        for (int e:graph[i])&#123;</span><br><span class="line">            if (!dfs(graph,flag,e)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[i] &#x3D; -1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
