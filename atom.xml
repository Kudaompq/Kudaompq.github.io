<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kudaompq的博客</title>
  
  <subtitle>Kudaompq</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-01-19T02:22:35.721Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Kudaompq</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拓扑算法</title>
    <link href="http://example.com/2021/01/19/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/01/19/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-19T01:43:14.000Z</published>
    <updated>2021-01-19T02:22:35.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="拓扑算法"><a href="#拓扑算法" class="headerlink" title="拓扑算法"></a>拓扑算法</h2><blockquote><p>适用于<strong>AOV有向无权图</strong></p></blockquote><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>找出入度为0的顶点</li><li>删除入度为0的点以及和它相关的边</li><li>重复上述步骤，直到找不到入度为0的点</li><li>如果输出顶点数小于总定点数，说明存在回路</li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><blockquote><p>BFS实现（广度优先搜索）</p></blockquote><ul><li>建立入度表，入度为0的节点入队</li><li>当队列不为空时，节点出队</li><li>出队节点的邻居入度减一</li><li>如果出队节点的邻接点入度为0，加入队列</li><li>直到队列为空</li></ul><blockquote><p>例题：<a href="https://leetcode-cn.com/problems/course-schedule/">https://leetcode-cn.com/problems/course-schedule/</a></p></blockquote><p><img src="/images/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/tuopu.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph &#x3D; new ArrayList[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建邻接表</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            graph[i] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        int[] vis &#x3D; new int[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建入度表</span><br><span class="line">        int[] info &#x3D; new int[numCourses];</span><br><span class="line">        for (int[] e:prerequisites)&#123;</span><br><span class="line">            graph[e[1]].add(e[0]);</span><br><span class="line">            info[e[0]]++;</span><br><span class="line">        &#125; </span><br><span class="line">        &#x2F;&#x2F;利用队列实现</span><br><span class="line">        Queue&lt;Integer&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;入度为0的时候入队</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            if (info[i] &#x3D;&#x3D; 0) q.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!q.isEmpty())&#123;</span><br><span class="line">            int k &#x3D; q.poll();</span><br><span class="line">            vis[k] &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F;邻接点入度-1，为0时入度</span><br><span class="line">            for (int e:graph[k])&#123;</span><br><span class="line">                if (--info[e] &#x3D;&#x3D; 0) q.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;所有点被访问过说明不存在回路，可以学完所有课程</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ;i++)&#123;</span><br><span class="line">            if (vis[i] &#x3D;&#x3D; 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DFS实现（深度优先搜索）</p></blockquote><ul><li>创建邻接表和flag数组用来判断是否访问过<ul><li>flag = 1 表示被自己访问过<ul><li>说明在本轮dfs循环中第二次被访问，说明有环，返回false</li></ul></li><li>flag = -1 被邻接点访问过<ul><li>说明其他点访问过这个点了,返回true</li></ul></li></ul></li><li>当前访问过节点i,flag[i] = 1</li><li>递归 访问当前点的邻接点</li><li>当前节点所有邻接点都遍历一遍，没有返回false，说明没有回环，flag[i] = -1</li><li>未发现环，返回true</li></ul><blockquote><p>代码实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph &#x3D; new ArrayList[numCourses];</span><br><span class="line">        int[] flag &#x3D; new int[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建邻接表</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            graph[i] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;  </span><br><span class="line">        for (int[] e:prerequisites)&#123;</span><br><span class="line">            graph[e[1]].add(e[0]);</span><br><span class="line">        &#125; </span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            if (!dfs(graph,flag,i)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean dfs(List&lt;Integer&gt;[] graph,int[] flag,int i)&#123;</span><br><span class="line">        if (flag[i] &#x3D;&#x3D; 1) return false;  &#x2F;&#x2F;说明这一轮第二次访问该点，是环路</span><br><span class="line">        if (flag[i] &#x3D;&#x3D; -1) return true; &#x2F;&#x2F;说明其他点已经访问过这个点 直接返回true就行</span><br><span class="line">        flag[i] &#x3D; 1;</span><br><span class="line">        for (int e:graph[i])&#123;</span><br><span class="line">            if (!dfs(graph,flag,e)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[i] &#x3D; -1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="拓扑算法" scheme="http://example.com/tags/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
