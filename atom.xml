<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kudaompq的博客</title>
  
  <subtitle>Kudaompq</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-01-20T08:20:24.750Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Kudaompq</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>matplotlib学习</title>
    <link href="http://example.com/2021/01/19/matplotlib%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/01/19/matplotlib%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-19T06:10:20.000Z</published>
    <updated>2021-01-20T08:20:24.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><blockquote><p>数据分析使用适当的方法对收集来的大量数据进行分析，帮助人们做出判断，以便采取适当行动</p></blockquote><h2 id="数据分析的流程"><a href="#数据分析的流程" class="headerlink" title="数据分析的流程"></a>数据分析的流程</h2><ul><li>提出问题</li><li>准备数据</li><li>分析数据</li><li>获得结论<ul><li>成果可视化</li><li>…..</li></ul></li></ul><hr><h1 id="Matplotlib概念"><a href="#Matplotlib概念" class="headerlink" title="Matplotlib概念"></a>Matplotlib概念</h1><blockquote><p>matplotlib:最流行的Python底层绘图库，<strong>主要做数据可视化图表</strong>，模仿MATLAB构建</p></blockquote><h2 id="为什么要学matplotlib"><a href="#为什么要学matplotlib" class="headerlink" title="为什么要学matplotlib"></a>为什么要学matplotlib</h2><ul><li>能将数据进行可视化，更直观的呈现</li><li>是数据更加客观、更具说服力</li></ul><h1 id="Matplotlib使用方法"><a href="#Matplotlib使用方法" class="headerlink" title="Matplotlib使用方法"></a>Matplotlib使用方法</h1><blockquote><p>导入pyplot模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br></pre></td></tr></table></figure><h2 id="折线图绘制"><a href="#折线图绘制" class="headerlink" title="折线图绘制"></a>折线图绘制</h2><blockquote><p>能够显示数据的变化趋势，反应事物的变化情况</p></blockquote><h3 id="绘制折现图"><a href="#绘制折现图" class="headerlink" title="绘制折现图"></a>绘制折现图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(序列1,序列2,label&#x3D;,color&#x3D;,linestyle&#x3D;&#39;&#39;,linewidth&#x3D;,alpha&#x3D;)</span><br><span class="line"></span><br><span class="line">#color 线条颜色 ‘r&#39;:红,&#39;g&#39;:绿,&#39;b&#39;:蓝,&#39;w&#39;:白,&#39;c&#39;:青,&#39;m&#39;洋红,&#39;y:&#39;黄,&#39;k&#39;:黑</span><br><span class="line">#支持RGB十六进制形式</span><br><span class="line">#linestyle 线条风格 ’-‘:实线 , &#39;--&#39;:虚线 , &#39;-.&#39;:点划线 , &#39;:&#39;:点虚线 ， &#39;&#39;:留空或空格，无线条</span><br><span class="line">#linewidth 线条宽度</span><br><span class="line">#alpha 透明度</span><br><span class="line">#label 标签名</span><br></pre></td></tr></table></figure><h3 id="展示图"><a href="#展示图" class="headerlink" title="展示图"></a>展示图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="设置图片大小"><a href="#设置图片大小" class="headerlink" title="设置图片大小"></a>设置图片大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize&#x3D;(宽,高),dpi&#x3D;)</span><br><span class="line"></span><br><span class="line">figsize&#x3D;():表示图片的大小</span><br><span class="line">dpi:图片的清晰程度，当图片模糊的时候可以传入dpi参数，让图片更清晰</span><br></pre></td></tr></table></figure><h3 id="保存图"><a href="#保存图" class="headerlink" title="保存图"></a>保存图</h3><blockquote><p>注意必须在绘图之后保存</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(&quot;.&#x2F;文件名.文件类型&quot;)</span><br><span class="line"></span><br><span class="line">可以保存为svg矢量图格式，放大不会有锯齿</span><br></pre></td></tr></table></figure><h3 id="设置x-y轴的刻度"><a href="#设置x-y轴的刻度" class="headerlink" title="设置x,y轴的刻度"></a>设置x,y轴的刻度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#x轴</span><br><span class="line">plt.xticks(序列)</span><br><span class="line"></span><br><span class="line">#y轴</span><br><span class="line">plt.yticks(序列)</span><br><span class="line"></span><br><span class="line">#用字符串作为刻度</span><br><span class="line">#取步长，数字和字符串一一对应，数据长度一样</span><br><span class="line">x &#x3D; range(0,120)</span><br><span class="line">y &#x3D; [random.randint(20,35) for i in range(120)]</span><br><span class="line">_xtick_labels &#x3D; [f&quot;&#123;i&#125;:&#123;j&#125;&quot; for i in range(10,12) for j in range(60)]</span><br><span class="line">plt.xticks(list(x)[::3],_xtick_labels[::3],rotation &#x3D; 270) </span><br><span class="line">#rotation旋转的度数</span><br><span class="line">#让列表x中的数据和_xticks上的数据都传入，最终会在x轴上一一对应显示</span><br><span class="line">#两组数据的长度必须一样，否则不能完全覆盖整个轴</span><br><span class="line">#使用列表的切分，每隔3个显示一个</span><br><span class="line">#为了字符串不被覆盖，使用rotation选项让字符串旋转270度显示</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置中文显示"><a href="#设置中文显示" class="headerlink" title="设置中文显示"></a>设置中文显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在代码中添加一行代码</span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]#黑体</span><br></pre></td></tr></table></figure><h3 id="设置图形信息"><a href="#设置图形信息" class="headerlink" title="设置图形信息"></a>设置图形信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#x轴的信息</span><br><span class="line">plt.xlable(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">#y轴的信息</span><br><span class="line">plt.ylable(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">#标题</span><br><span class="line">plt.title(&quot;&quot;)</span><br></pre></td></tr></table></figure><h3 id="绘制网格"><a href="#绘制网格" class="headerlink" title="绘制网格"></a>绘制网格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.grid(alpha &#x3D; ,linestyle&#x3D; )</span><br><span class="line"></span><br><span class="line">#linestyle线条风格 ’-‘:实线 , &#39;--&#39;:虚线 , &#39;-.&#39;:点划线 , &#39;:&#39;:点虚线 ， &#39;&#39;:留空或空格，无线条</span><br><span class="line"></span><br><span class="line">alpha:透明度  默认1 </span><br></pre></td></tr></table></figure><h3 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1.设置lable参数</span><br><span class="line">plt.plot(x,y1,label&#x3D;&quot;自己&quot;)</span><br><span class="line">plt.plot(x,y2,label&#x3D;&quot;同桌&quot;)</span><br><span class="line">#2.添加图例</span><br><span class="line">plt.legend(loc&#x3D;)</span><br><span class="line">#loc表示显示位置可以Ctrl+b查找</span><br><span class="line">best 0</span><br><span class="line">upper right 1</span><br><span class="line">upper left  2</span><br><span class="line">lower left  3</span><br><span class="line">lower right 4</span><br><span class="line">right       5</span><br><span class="line">center left 6</span><br><span class="line">center right7</span><br><span class="line">lower center8</span><br><span class="line">upper center9</span><br><span class="line">center      10</span><br></pre></td></tr></table></figure><h2 id="散点图绘制"><a href="#散点图绘制" class="headerlink" title="散点图绘制"></a>散点图绘制</h2><blockquote><p>判断变量之间是否存在数量关联趋势，站视离群点（分布规律）</p></blockquote><h3 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h3><blockquote><p>绘制散点图和折线图方法基本相同</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(序列1,序列2)</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]#黑体</span><br><span class="line">#3月</span><br><span class="line">y_3 &#x3D; [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23]</span><br><span class="line">#10月</span><br><span class="line">y_10 &#x3D; [26,26,28,19,21,17,16,19,18,20,20,19,22,23,17,20,21,20,22,15,11,15,5,13,17,10,11,13,12,13,6]</span><br><span class="line">#设置图的大小</span><br><span class="line">plt.figure(figsize&#x3D;(20,8),dpi&#x3D;80)</span><br><span class="line">x_10 &#x3D; range(51,82)</span><br><span class="line">x_3 &#x3D; range(1,32)</span><br><span class="line">#画出三月十月的散点图</span><br><span class="line">plt.scatter(x_3,y_3,label &#x3D; &quot;3月&quot;)</span><br><span class="line">plt.scatter(x_10,y_10,label &#x3D; &#39;10月&#39;)</span><br><span class="line">#调整x轴刻度</span><br><span class="line">_x &#x3D; list(x_3) + list(x_10)</span><br><span class="line">_xtick_labels &#x3D; [f&quot;3月&#123;i&#125;日&quot; for i in x_3]</span><br><span class="line">_xtick_labels +&#x3D; [f&quot;10月&#123;i&#125;日&quot; for i in x_3]</span><br><span class="line">#设置刻度</span><br><span class="line">plt.xticks(_x[::3],_xtick_labels[::3],rotation &#x3D; 45)</span><br><span class="line">#设置x，y轴以及标题信息</span><br><span class="line">plt.xlabel(&quot;时间&quot;)</span><br><span class="line">plt.ylabel(&quot;温度&quot;)</span><br><span class="line">plt.title(&quot;标题&quot;)</span><br><span class="line">plt.legend();</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="条形图绘制"><a href="#条形图绘制" class="headerlink" title="条形图绘制"></a>条形图绘制</h2><blockquote><p>绘制<strong>离散</strong>的数据，能够一眼看出各个数据的大小，比较数据之间的差别</p><p>多用于数量统计和频率统计</p></blockquote><h3 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.bar(序列1，序列2，width)</span><br><span class="line"></span><br><span class="line">#width:宽度</span><br></pre></td></tr></table></figure><h3 id="绘制横着的条形图"><a href="#绘制横着的条形图" class="headerlink" title="绘制横着的条形图"></a>绘制横着的条形图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.barh(序列1，序列2，height&#x3D;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;height:线条粗细</span><br></pre></td></tr></table></figure><h3 id="绘图注意点"><a href="#绘图注意点" class="headerlink" title="绘图注意点"></a>绘图注意点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#条形错开演示，需要把坐标往右移宽度大小，否则会重合</span><br><span class="line">例：</span><br><span class="line">plt.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]#黑体</span><br><span class="line">a &#x3D; [&quot;猩球崛起3：终极之战&quot;,&quot;敦刻尔克&quot;,&quot;蜘蛛侠：英雄归来&quot;,&quot;战狼2&quot;]</span><br><span class="line">b_16 &#x3D; [15746,312,4497,319]</span><br><span class="line">b_15 &#x3D; [12357,156,2045,168]</span><br><span class="line">b_14 &#x3D; [2358,399,2358,362]</span><br><span class="line"></span><br><span class="line">#将x轴往右移动bir_width的宽度</span><br><span class="line">bir_width &#x3D; 0.2</span><br><span class="line">x_14 &#x3D; list(range(len(a)))</span><br><span class="line">x_15 &#x3D; [i + bir_width for i in x_14]</span><br><span class="line">x_16 &#x3D; [i + bir_width * 2 for i in x_14]</span><br><span class="line">plt.figure(figsize&#x3D;(20,15),dpi &#x3D; 80)</span><br><span class="line">plt.bar(x_16,b_16,width&#x3D;bir_width,label &#x3D; &quot;16日&quot;)</span><br><span class="line">plt.bar(x_15,b_15,width&#x3D;bir_width,label &#x3D; &#39;15日&#39;)</span><br><span class="line">plt.bar(x_14,b_14,width&#x3D;bir_width,label &#x3D; &#39;14日&#39;)</span><br><span class="line">plt.xticks(x_15,a)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="直方图绘制"><a href="#直方图绘制" class="headerlink" title="直方图绘制"></a>直方图绘制</h2><blockquote><p>直方图一般用于没有统计过的数据</p></blockquote><h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(序列,分组数,density&#x3D;)</span><br><span class="line"></span><br><span class="line">#组数:将数据分组，当数据在100个以内的时候，按数据多少常分为5-12组</span><br><span class="line"></span><br><span class="line">#组距:每个小组的两个端点的距离</span><br><span class="line"></span><br><span class="line">组数 &#x3D; 极差 &#x2F; 组距 &#x3D; (max(a) - min (a)) &#x2F; 组距</span><br><span class="line"></span><br><span class="line">#density &#x3D; True 表示使用比率显示</span><br></pre></td></tr></table></figure><h3 id="直方图的坐标轴"><a href="#直方图的坐标轴" class="headerlink" title="直方图的坐标轴"></a>直方图的坐标轴</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(range(min(a),max(a) + bin_width,bin_width))</span><br><span class="line">#需要在max(a)后面再加一个组距这样才能显示完全</span><br></pre></td></tr></table></figure><blockquote><p>更多图像样式网站：<a href="https://matplotlib.org/gallery/index.html">https://matplotlib.org/gallery/index.html</a></p></blockquote><blockquote><p>图表制作网站：<a href="https://echarts.apache.org/">https://echarts.apache.org/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据分析" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="-matplotlib -python" scheme="http://example.com/tags/matplotlib-python/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal算法</title>
    <link href="http://example.com/2021/01/19/Kruskal%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/01/19/Kruskal%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-19T04:22:16.000Z</published>
    <updated>2021-01-19T04:27:26.672Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><blockquote><p>用于解决最小生成树问题</p><p>最小生成树：权值最小的带权无向图</p></blockquote><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>基于贪心思想</li><li>将所有的边按照权值从小到大排列，接着按照顺序选取每条边</li><li>如果这条边的两个端点不属于同一个集合就合并，知道所有的点属于同一个集合</li><li>使用并查集合并</li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>例题：<a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">https://leetcode-cn.com/problems/min-cost-to-connect-all-points/</a></p><p><img src="/images/Kruskal%E7%AE%97%E6%B3%95/Kruskal.png"></p><p>思路：</p><ul><li>题目：连接所有点的最小费用，可以从题目中得出是最小生成树问题</li><li>先创建一个Edge类，用来存储点的两个点以及它们之间的长度</li><li>创建一个并查集类</li><li>创建一个List存储所有可能存在的边</li><li>所有的边按长度从小到大排序</li><li>按顺序将n条边合并，并记录它们的长度之和</li><li>注意：如果两个端点都属于同一个连通图，那么不合并</li></ul><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minCostConnectPoints(int[][] points) &#123;</span><br><span class="line">        int n &#x3D; points.length;</span><br><span class="line">        UnionFind u &#x3D; new UnionFind(n);</span><br><span class="line">        List&lt;Edge&gt; edges &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; n ; i++)&#123;</span><br><span class="line">            for (int j &#x3D; i + 1 ; j &lt; n ; j++)&#123;</span><br><span class="line">                edges.add(new Edge(distance(points,i,j) , i , j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(edges,new Comparator&lt;Edge&gt;()&#123;</span><br><span class="line">            public int compare(Edge a,Edge b)&#123;</span><br><span class="line">                return a.len - b.len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        int ans &#x3D; 0,num &#x3D; 1;</span><br><span class="line">        for (Edge edge:edges)&#123;</span><br><span class="line">            int len &#x3D; edge.len;</span><br><span class="line">            int x &#x3D; edge.x;</span><br><span class="line">            int y &#x3D; edge.y;</span><br><span class="line">            if (u.Union(x,y))&#123;</span><br><span class="line">                ans +&#x3D; len;</span><br><span class="line">                num++;</span><br><span class="line">                if (num &#x3D;&#x3D; n) break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public int distance(int[][] points,int x,int y)&#123;</span><br><span class="line">        return Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class UnionFind&#123;</span><br><span class="line">    int parents[];</span><br><span class="line">    int rank[];</span><br><span class="line">    int n;</span><br><span class="line">    public UnionFind(int n)&#123;</span><br><span class="line">        parents &#x3D; new int[n];</span><br><span class="line">        rank &#x3D; new int[n];</span><br><span class="line">        this.n &#x3D; n;</span><br><span class="line">        Arrays.fill(rank,1);</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; n ; i++)&#123;</span><br><span class="line">            parents[i] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find(int x)&#123;</span><br><span class="line">        return parents[x] &#x3D;&#x3D; x ? x : find(parents[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean Union(int x,int y)&#123;</span><br><span class="line">        int f1 &#x3D; find(x);</span><br><span class="line">        int f2 &#x3D; find(y);</span><br><span class="line">        if (f1 &#x3D;&#x3D; f2) return false;</span><br><span class="line">        if (rank[f1] &lt; rank[f2])&#123;</span><br><span class="line">            int temp &#x3D; f1;</span><br><span class="line">            f1 &#x3D; f2;</span><br><span class="line">            f2 &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        rank[f1] +&#x3D; rank[f2];</span><br><span class="line">        parents[f2] &#x3D; f1;</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Edge&#123;</span><br><span class="line">    int len;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    public Edge(int len , int x , int y)&#123;</span><br><span class="line">        this.len &#x3D; len;</span><br><span class="line">        this.x &#x3D; x;</span><br><span class="line">        this.y &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Kruskal算法" scheme="http://example.com/tags/Kruskal%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>并查集算法</title>
    <link href="http://example.com/2021/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-19T04:14:18.000Z</published>
    <updated>2021-01-19T04:21:14.668Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="并查集算法"><a href="#并查集算法" class="headerlink" title="并查集算法"></a>并查集算法</h2><blockquote><p>用于求解不相交集合的合并问题</p></blockquote><ul><li><p>并查集又称Find_Union算法</p><ul><li><p>Find：确定元素属于哪一子集</p><ul><li>采用压缩路径的方法，递归找到该点的<strong>最终</strong>父节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int find(int x)&#123;</span><br><span class="line">return x &#x3D;&#x3D; parents[x] ? x : find(parents[x])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>Union：将两个子集合并成一个子集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void Union(int x,int y)&#123;</span><br><span class="line">int find_x &#x3D; find(x);</span><br><span class="line">int find_y &#x3D; find(y);</span><br><span class="line">if (find_x &#x3D;&#x3D; find_y) return;</span><br><span class="line">parents[find_x] &#x3D; find_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>按秩合并</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public void Union(int x,int y)&#123;</span><br><span class="line">int find_x &#x3D; find(x);</span><br><span class="line">int find_y &#x3D; find(y);</span><br><span class="line">if (find_x &#x3D;&#x3D; find_y) return;</span><br><span class="line">if (rank[find_x] &lt;&#x3D; rank[find_y])</span><br><span class="line">parents[find_x] &#x3D; find_y;</span><br><span class="line">else</span><br><span class="line">parents[find_y] &#x3D; find_x;</span><br><span class="line">if (rank[find_x] &#x3D;&#x3D; rank[find_y] &amp;&amp; find_x !&#x3D; find_y)</span><br><span class="line">rank[find_y]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind&#123;</span><br><span class="line">int n;</span><br><span class="line">int[] rank;</span><br><span class="line">int[] parents;</span><br><span class="line">&#x2F;&#x2F;初始化父亲数组和秩数组</span><br><span class="line">public UnionFind(int n)&#123;</span><br><span class="line">this.n &#x3D; n;</span><br><span class="line">rank &#x3D; new int[n];</span><br><span class="line">Arrays.fill(rank,1);</span><br><span class="line">parents &#x3D; new int[n];</span><br><span class="line">for (int i &#x3D; 0 ; i &lt; n ;i++)&#123;</span><br><span class="line">parents[i] &#x3D; [i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public int find(int x)&#123;</span><br><span class="line">return parents[x] &#x3D;&#x3D; x ? x:find(parents[x]);</span><br><span class="line">&#125;</span><br><span class="line">public void Union(int x,int y)&#123;</span><br><span class="line">int find_x &#x3D; find(x);</span><br><span class="line">int find_y &#x3D; find(y);</span><br><span class="line">if (find_x &#x3D;&#x3D; find_y) return;</span><br><span class="line">if (rank[find_x] &lt;&#x3D; rank[find_y])</span><br><span class="line">parents[find_x] &#x3D; find_y;</span><br><span class="line">else</span><br><span class="line">parents[find_y] &#x3D; find_x;</span><br><span class="line">if (rank[find_x] &#x3D;&#x3D; rank[find_y] &amp;&amp; find_x !&#x3D; find_y)</span><br><span class="line">rank[find_y]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="并查集算法" scheme="http://example.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>拓扑算法</title>
    <link href="http://example.com/2021/01/19/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/01/19/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-19T01:43:14.000Z</published>
    <updated>2021-01-19T02:22:35.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="拓扑算法"><a href="#拓扑算法" class="headerlink" title="拓扑算法"></a>拓扑算法</h2><blockquote><p>适用于<strong>AOV有向无权图</strong></p></blockquote><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>找出入度为0的顶点</li><li>删除入度为0的点以及和它相关的边</li><li>重复上述步骤，直到找不到入度为0的点</li><li>如果输出顶点数小于总定点数，说明存在回路</li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><blockquote><p>BFS实现（广度优先搜索）</p></blockquote><ul><li>建立入度表，入度为0的节点入队</li><li>当队列不为空时，节点出队</li><li>出队节点的邻居入度减一</li><li>如果出队节点的邻接点入度为0，加入队列</li><li>直到队列为空</li></ul><blockquote><p>例题：<a href="https://leetcode-cn.com/problems/course-schedule/">https://leetcode-cn.com/problems/course-schedule/</a></p></blockquote><p><img src="/images/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/tuopu.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph &#x3D; new ArrayList[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建邻接表</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            graph[i] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        int[] vis &#x3D; new int[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建入度表</span><br><span class="line">        int[] info &#x3D; new int[numCourses];</span><br><span class="line">        for (int[] e:prerequisites)&#123;</span><br><span class="line">            graph[e[1]].add(e[0]);</span><br><span class="line">            info[e[0]]++;</span><br><span class="line">        &#125; </span><br><span class="line">        &#x2F;&#x2F;利用队列实现</span><br><span class="line">        Queue&lt;Integer&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;入度为0的时候入队</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            if (info[i] &#x3D;&#x3D; 0) q.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!q.isEmpty())&#123;</span><br><span class="line">            int k &#x3D; q.poll();</span><br><span class="line">            vis[k] &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F;邻接点入度-1，为0时入度</span><br><span class="line">            for (int e:graph[k])&#123;</span><br><span class="line">                if (--info[e] &#x3D;&#x3D; 0) q.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;所有点被访问过说明不存在回路，可以学完所有课程</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ;i++)&#123;</span><br><span class="line">            if (vis[i] &#x3D;&#x3D; 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DFS实现（深度优先搜索）</p></blockquote><ul><li>创建邻接表和flag数组用来判断是否访问过<ul><li>flag = 1 表示被自己访问过<ul><li>说明在本轮dfs循环中第二次被访问，说明有环，返回false</li></ul></li><li>flag = -1 被邻接点访问过<ul><li>说明其他点访问过这个点了,返回true</li></ul></li></ul></li><li>当前访问过节点i,flag[i] = 1</li><li>递归 访问当前点的邻接点</li><li>当前节点所有邻接点都遍历一遍，没有返回false，说明没有回环，flag[i] = -1</li><li>未发现环，返回true</li></ul><blockquote><p>代码实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph &#x3D; new ArrayList[numCourses];</span><br><span class="line">        int[] flag &#x3D; new int[numCourses];</span><br><span class="line">        &#x2F;&#x2F;创建邻接表</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            graph[i] &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;  </span><br><span class="line">        for (int[] e:prerequisites)&#123;</span><br><span class="line">            graph[e[1]].add(e[0]);</span><br><span class="line">        &#125; </span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            if (!dfs(graph,flag,i)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean dfs(List&lt;Integer&gt;[] graph,int[] flag,int i)&#123;</span><br><span class="line">        if (flag[i] &#x3D;&#x3D; 1) return false;  &#x2F;&#x2F;说明这一轮第二次访问该点，是环路</span><br><span class="line">        if (flag[i] &#x3D;&#x3D; -1) return true; &#x2F;&#x2F;说明其他点已经访问过这个点 直接返回true就行</span><br><span class="line">        flag[i] &#x3D; 1;</span><br><span class="line">        for (int e:graph[i])&#123;</span><br><span class="line">            if (!dfs(graph,flag,e)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[i] &#x3D; -1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="拓扑算法" scheme="http://example.com/tags/%E6%8B%93%E6%89%91%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
